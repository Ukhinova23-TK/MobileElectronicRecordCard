// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Role.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// Role TABLE
class TableRole extends SqfEntityTableBase {
  TableRole() {
    // declare properties of EntityTable
    tableName = 'role';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableRole();
  }
}

// Student_group TABLE
class TableStudent_group extends SqfEntityTableBase {
  TableStudent_group() {
    // declare properties of EntityTable
    tableName = 'student_group';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('full_name', DbType.text),
      SqfEntityFieldBase('admission_date', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('version', DbType.integer, isNotNull: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableStudent_group();
  }
}

// Subject TABLE
class TableSubject extends SqfEntityTableBase {
  TableSubject() {
    // declare properties of EntityTable
    tableName = 'subject';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('version', DbType.integer, isNotNull: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSubject();
  }
}

// Mark TABLE
class TableMark extends SqfEntityTableBase {
  TableMark() {
    // declare properties of EntityTable
    tableName = 'mark';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('title', DbType.text, isNotNull: true),
      SqfEntityFieldBase('value', DbType.integer, isNotNull: true),
      SqfEntityFieldBase('version', DbType.integer, isNotNull: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableMark();
  }
}

// Control_type TABLE
class TableControl_type extends SqfEntityTableBase {
  TableControl_type() {
    // declare properties of EntityTable
    tableName = 'control_type';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('title', DbType.text, isNotNull: true),
      SqfEntityFieldBase('version', DbType.integer, isNotNull: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableControl_type();
  }
}

// User TABLE
class TableUser extends SqfEntityTableBase {
  TableUser() {
    // declare properties of EntityTable
    tableName = 'user';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('login', DbType.text, isNotNull: true),
      SqfEntityFieldBase('last_name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('first_name', DbType.text, isNotNull: true),
      SqfEntityFieldBase('middle_name', DbType.text),
      SqfEntityFieldBase('record_book_number', DbType.text),
      SqfEntityFieldBase('version', DbType.integer, isNotNull: true),
      SqfEntityFieldRelationshipBase(
          TableStudent_group.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'groupId'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableUser();
  }
}

// User_subject_control_type TABLE
class TableUser_subject_control_type extends SqfEntityTableBase {
  TableUser_subject_control_type() {
    // declare properties of EntityTable
    tableName = 'user_subject_control_type';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('semester', DbType.integer, isNotNull: true),
      SqfEntityFieldBase('hours_number', DbType.integer),
      SqfEntityFieldBase('version', DbType.integer, isNotNull: true),
      SqfEntityFieldRelationshipBase(
          TableUser.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'teacher_id'),
      SqfEntityFieldRelationshipBase(
          TableSubject.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'subject_id'),
      SqfEntityFieldRelationshipBase(
          TableControl_type.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'control_type_id'),
      SqfEntityFieldRelationshipBase(
          TableUser.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'student_id'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableUser_subject_control_type();
  }
}

// Student_mark TABLE
class TableStudent_mark extends SqfEntityTableBase {
  TableStudent_mark() {
    // declare properties of EntityTable
    tableName = 'student_mark';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('completion_date', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('version', DbType.integer, isNotNull: true),
      SqfEntityFieldBase('saved', DbType.bool,
          defaultValue: false, isNotNull: true),
      SqfEntityFieldRelationshipBase(
          TableMark.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'mark_id'),
      SqfEntityFieldRelationshipBase(
          TableUser_subject_control_type.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'user_subject_control_type_id'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableStudent_mark();
  }
}

// User_role TABLE
class TableUser_role extends SqfEntityTableBase {
  TableUser_role() {
    // declare properties of EntityTable
    tableName = 'user_role';
    relationType = RelationType.MANY_TO_MANY;
    primaryKeyName = '';
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TableRole.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'roleId',
          isPrimaryKeyField: true),
      SqfEntityFieldRelationshipBase(
          TableUser.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'userId',
          isPrimaryKeyField: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableUser_role();
  }
}

// Mark_control_type TABLE
class TableMark_control_type extends SqfEntityTableBase {
  TableMark_control_type() {
    // declare properties of EntityTable
    tableName = 'mark_control_type';
    relationType = RelationType.MANY_TO_MANY;
    primaryKeyName = '';
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TableControl_type.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'control_typeId',
          isPrimaryKeyField: true),
      SqfEntityFieldRelationshipBase(
          TableMark.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'markId',
          isPrimaryKeyField: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableMark_control_type();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class ElectronicRecordCardDbModel extends SqfEntityModelProvider {
  ElectronicRecordCardDbModel() {
    databaseName = electronicRecordCardDbModel.databaseName;
    password = electronicRecordCardDbModel.password;
    dbVersion = electronicRecordCardDbModel.dbVersion;
    preSaveAction = electronicRecordCardDbModel.preSaveAction;
    logFunction = electronicRecordCardDbModel.logFunction;
    databaseTables = [
      TableRole.getInstance,
      TableStudent_group.getInstance,
      TableSubject.getInstance,
      TableMark.getInstance,
      TableControl_type.getInstance,
      TableUser.getInstance,
      TableUser_subject_control_type.getInstance,
      TableStudent_mark.getInstance,
      TableUser_role.getInstance,
      TableMark_control_type.getInstance,
    ];

    bundledDatabasePath = electronicRecordCardDbModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = electronicRecordCardDbModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Role
class Role extends TableBase {
  Role({this.id, this.name}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Role.withFields(this.id, this.name) {
    _setDefaultValues();
  }
  Role.withId(this.id, this.name) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Role.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }

    isSaved = true;
  }
  // FIELDS (Role)
  int? id;
  String? name;
  bool? isSaved;
  // end FIELDS (Role)

// COLLECTIONS & VIRTUALS (Role)
  ///(RelationType.MANY_TO_MANY) (user_role) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plUsers', 'plField2'..]) or so on..
  List<User>? plUsers;

  /// get User(s) filtered by userId IN user_role
  UserFilterBuilder? getUsers(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return User()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where('id IN (SELECT userId FROM user_role WHERE roleId=?)',
            parameterValue: id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Role)

  static const bool _softDeleteActivated = false;
  RoleManager? __mnRole;

  RoleManager get _mnRole {
    return __mnRole = __mnRole ?? RoleManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }

// COLLECTIONS (Role)
    if (!forQuery) {
      map['Users'] = await getUsers()!.toMapList();
    }
// END COLLECTIONS (Role)

    return map;
  }

  /// This method returns Json String [Role]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Role]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [id, name];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, name];
  }

  static Future<List<Role>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Role.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Role>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Role>[];
    try {
      objList = list
          .map((role) => Role.fromMap(role as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Role.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Role>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Role> objList = <Role>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Role.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('role.plUsers') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUsers'))) {
          /*_loadedfields!.add('role.plUsers'); */ obj.plUsers = obj.plUsers ??
              await obj.getUsers()!.toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Role by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Role] if exist, otherwise returns null
  Future<Role?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Role? obj;
    final data = await _mnRole.getById([id]);
    if (data.length != 0) {
      obj = Role.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('role.plUsers') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUsers'))) {
          /*_loadedfields!.add('role.plUsers'); */ obj.plUsers = obj.plUsers ??
              await obj.getUsers()!.toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Role) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnRole.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnRole.update(this);
    }

    return id;
  }

  /// Saves the (Role) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnRole.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnRole.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<Role> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Role> roles,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ElectronicRecordCardDbModel().batchStart();
    for (final obj in roles) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await ElectronicRecordCardDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnRole.rawInsert(
          'INSERT OR REPLACE INTO role (id, name)  VALUES (?,?)',
          [id, name],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Role id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Role id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Role Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Role>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Role> roles,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnRole.rawInsertAll(
        'INSERT OR REPLACE INTO role (id, name)  VALUES (?,?)', roles,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Role

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Role invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnRole
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnRole.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Role] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  RoleFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RoleFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  RoleFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RoleFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion role

// region RoleField
class RoleField extends FilterBase {
  RoleField(RoleFilterBuilder roleFB) : super(roleFB);

  @override
  RoleFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as RoleFilterBuilder;
  }

  @override
  RoleFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as RoleFilterBuilder;
  }

  @override
  RoleFilterBuilder isNull() {
    return super.isNull() as RoleFilterBuilder;
  }

  @override
  RoleFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as RoleFilterBuilder;
  }

  @override
  RoleFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as RoleFilterBuilder;
  }

  @override
  RoleFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as RoleFilterBuilder;
  }

  @override
  RoleFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as RoleFilterBuilder;
  }

  @override
  RoleFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as RoleFilterBuilder;
  }

  @override
  RoleFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as RoleFilterBuilder;
  }

  @override
  RoleFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as RoleFilterBuilder;
  }

  @override
  RoleFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as RoleFilterBuilder;
  }

  @override
  RoleFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as RoleFilterBuilder;
  }

  @override
  RoleField get not {
    return super.not as RoleField;
  }
}
// endregion RoleField

// region RoleFilterBuilder
class RoleFilterBuilder extends ConjunctionBase {
  RoleFilterBuilder(Role obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnRole = obj._mnRole;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  RoleManager? _mnRole;

  /// put the sql keyword 'AND'
  @override
  RoleFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  RoleFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  RoleFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  RoleFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  RoleFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  RoleFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  RoleFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  RoleFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  RoleFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  RoleFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  RoleFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  RoleField _setField(RoleField? field, String colName, DbType dbtype) {
    return RoleField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  RoleField? _id;
  RoleField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  RoleField? _name;
  RoleField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  /// Deletes List<Role> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnRole!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnRole!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from role ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnRole!.updateBatch(qparams, values);
  }

  /// This method always returns [Role] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Role?
  @override
  Future<Role?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnRole!.toList(qparams);
    final data = await objFuture;
    Role? obj;
    if (data.isNotEmpty) {
      obj = Role.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('role.plUsers') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUsers'))) {
          /*_loadedfields!.add('role.plUsers'); */ obj.plUsers = obj.plUsers ??
              await obj.getUsers()!.toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Role]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Role?
  @override
  Future<Role> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Role();
  }

  /// This method returns int. [Role]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? roleCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final rolesFuture = await _mnRole!.toList(qparams);
    final int count = rolesFuture[0]['CNT'] as int;
    if (roleCount != null) {
      roleCount(count);
    }
    return count;
  }

  /// This method returns List<Role> [Role]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Role>
  @override
  Future<List<Role>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Role> rolesData = await Role.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return rolesData;
  }

  /// This method returns Json String [Role]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Role]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Role]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnRole!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Role]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM role WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnRole!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Role]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnRole!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Role.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnRole!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion RoleFilterBuilder

// region RoleFields
class RoleFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }
}
// endregion RoleFields

//region RoleManager
class RoleManager extends SqfEntityProvider {
  RoleManager()
      : super(ElectronicRecordCardDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'role';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion RoleManager
// region Student_group
class Student_group extends TableBase {
  Student_group(
      {this.id, this.name, this.full_name, this.admission_date, this.version}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Student_group.withFields(
      this.id, this.name, this.full_name, this.admission_date, this.version) {
    _setDefaultValues();
  }
  Student_group.withId(
      this.id, this.name, this.full_name, this.admission_date, this.version) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Student_group.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['full_name'] != null) {
      full_name = o['full_name'].toString();
    }
    if (o['admission_date'] != null) {
      admission_date = int.tryParse(o['admission_date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['admission_date'].toString())!)
          : DateTime.tryParse(o['admission_date'].toString());
    }
    if (o['version'] != null) {
      version = int.tryParse(o['version'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Student_group)
  int? id;
  String? name;
  String? full_name;
  DateTime? admission_date;
  int? version;
  bool? isSaved;
  // end FIELDS (Student_group)

// COLLECTIONS & VIRTUALS (Student_group)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plUsers', 'plField2'..]) or so on..
  List<User>? plUsers;

  /// get User(s) filtered by id=groupId
  UserFilterBuilder? getUsers(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return User()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .groupId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Student_group)

  static const bool _softDeleteActivated = false;
  Student_groupManager? __mnStudent_group;

  Student_groupManager get _mnStudent_group {
    return __mnStudent_group = __mnStudent_group ?? Student_groupManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (full_name != null || !forView) {
      map['full_name'] = full_name;
    }
    if (admission_date != null) {
      map['admission_date'] = forJson
          ? '$admission_date!.year-$admission_date!.month-$admission_date!.day'
          : forQuery
              ? DateTime(admission_date!.year, admission_date!.month,
                      admission_date!.day)
                  .millisecondsSinceEpoch
              : admission_date;
    } else if (admission_date != null || !forView) {
      map['admission_date'] = null;
    }
    if (version != null || !forView) {
      map['version'] = version;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (full_name != null || !forView) {
      map['full_name'] = full_name;
    }
    if (admission_date != null) {
      map['admission_date'] = forJson
          ? '$admission_date!.year-$admission_date!.month-$admission_date!.day'
          : forQuery
              ? DateTime(admission_date!.year, admission_date!.month,
                      admission_date!.day)
                  .millisecondsSinceEpoch
              : admission_date;
    } else if (admission_date != null || !forView) {
      map['admission_date'] = null;
    }
    if (version != null || !forView) {
      map['version'] = version;
    }

// COLLECTIONS (Student_group)
    if (!forQuery) {
      map['Users'] = await getUsers()!.toMapList();
    }
// END COLLECTIONS (Student_group)

    return map;
  }

  /// This method returns Json String [Student_group]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Student_group]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      id,
      name,
      full_name,
      admission_date != null ? admission_date!.millisecondsSinceEpoch : null,
      version
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      full_name,
      admission_date != null ? admission_date!.millisecondsSinceEpoch : null,
      version
    ];
  }

  static Future<List<Student_group>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Student_group.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Student_group>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Student_group>[];
    try {
      objList = list
          .map((student_group) =>
              Student_group.fromMap(student_group as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Student_group.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Student_group>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Student_group> objList = <Student_group>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Student_group.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('student_group.plUsers') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUsers'))) {
          /*_loadedfields!.add('student_group.plUsers'); */ obj.plUsers =
              obj.plUsers ??
                  await obj.getUsers()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Student_group by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Student_group] if exist, otherwise returns null
  Future<Student_group?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Student_group? obj;
    final data = await _mnStudent_group.getById([id]);
    if (data.length != 0) {
      obj = Student_group.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('student_group.plUsers') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUsers'))) {
          /*_loadedfields!.add('student_group.plUsers'); */ obj.plUsers =
              obj.plUsers ??
                  await obj.getUsers()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Student_group) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnStudent_group.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnStudent_group.update(this);
    }

    return id;
  }

  /// Saves the (Student_group) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnStudent_group.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnStudent_group.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<Student_group> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Student_group> student_groups,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ElectronicRecordCardDbModel().batchStart();
    for (final obj in student_groups) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await ElectronicRecordCardDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnStudent_group.rawInsert(
          'INSERT OR REPLACE INTO student_group (id, name, full_name, admission_date, version)  VALUES (?,?,?,?,?)',
          [
            id,
            name,
            full_name,
            admission_date != null
                ? admission_date!.millisecondsSinceEpoch
                : null,
            version
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Student_group id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Student_group id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Student_group Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Student_group>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Student_group> student_groups,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnStudent_group.rawInsertAll(
        'INSERT OR REPLACE INTO student_group (id, name, full_name, admission_date, version)  VALUES (?,?,?,?,?)',
        student_groups,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Student_group

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Student_group invoked (id=$id)');
    if (await User().select().groupId.equals(id).and.toCount() > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (User.groupId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnStudent_group
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnStudent_group.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Student_group] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Student_groupFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Student_groupFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Student_groupFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Student_groupFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion student_group

// region Student_groupField
class Student_groupField extends FilterBase {
  Student_groupField(Student_groupFilterBuilder student_groupFB)
      : super(student_groupFB);

  @override
  Student_groupFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Student_groupFilterBuilder;
  }

  @override
  Student_groupFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Student_groupFilterBuilder;
  }

  @override
  Student_groupFilterBuilder isNull() {
    return super.isNull() as Student_groupFilterBuilder;
  }

  @override
  Student_groupFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Student_groupFilterBuilder;
  }

  @override
  Student_groupFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Student_groupFilterBuilder;
  }

  @override
  Student_groupFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Student_groupFilterBuilder;
  }

  @override
  Student_groupFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Student_groupFilterBuilder;
  }

  @override
  Student_groupFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Student_groupFilterBuilder;
  }

  @override
  Student_groupFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Student_groupFilterBuilder;
  }

  @override
  Student_groupFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Student_groupFilterBuilder;
  }

  @override
  Student_groupFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Student_groupFilterBuilder;
  }

  @override
  Student_groupFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Student_groupFilterBuilder;
  }

  @override
  Student_groupField get not {
    return super.not as Student_groupField;
  }
}
// endregion Student_groupField

// region Student_groupFilterBuilder
class Student_groupFilterBuilder extends ConjunctionBase {
  Student_groupFilterBuilder(Student_group obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnStudent_group = obj._mnStudent_group;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Student_groupManager? _mnStudent_group;

  /// put the sql keyword 'AND'
  @override
  Student_groupFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Student_groupFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Student_groupFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Student_groupFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Student_groupFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Student_groupFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Student_groupFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Student_groupFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Student_groupFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Student_groupFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Student_groupFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Student_groupField _setField(
      Student_groupField? field, String colName, DbType dbtype) {
    return Student_groupField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Student_groupField? _id;
  Student_groupField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  Student_groupField? _name;
  Student_groupField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  Student_groupField? _full_name;
  Student_groupField get full_name {
    return _full_name = _setField(_full_name, 'full_name', DbType.text);
  }

  Student_groupField? _admission_date;
  Student_groupField get admission_date {
    return _admission_date =
        _setField(_admission_date, 'admission_date', DbType.date);
  }

  Student_groupField? _version;
  Student_groupField get version {
    return _version = _setField(_version, 'version', DbType.integer);
  }

  /// Deletes List<Student_group> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (User) according to DeleteRule.NO_ACTION

    final idListUserBYgroupId = toListPrimaryKeySQL(false);
    final resUserBYgroupId = await User()
        .select()
        .where('groupId IN (${idListUserBYgroupId['sql']})',
            parameterValue: idListUserBYgroupId['args'])
        .toCount();
    if (resUserBYgroupId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (User.groupId)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnStudent_group!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnStudent_group!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from student_group ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnStudent_group!.updateBatch(qparams, values);
  }

  /// This method always returns [Student_group] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Student_group?
  @override
  Future<Student_group?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnStudent_group!.toList(qparams);
    final data = await objFuture;
    Student_group? obj;
    if (data.isNotEmpty) {
      obj = Student_group.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('student_group.plUsers') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUsers'))) {
          /*_loadedfields!.add('student_group.plUsers'); */ obj.plUsers =
              obj.plUsers ??
                  await obj.getUsers()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Student_group]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Student_group?
  @override
  Future<Student_group> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Student_group();
  }

  /// This method returns int. [Student_group]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? student_groupCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final student_groupsFuture = await _mnStudent_group!.toList(qparams);
    final int count = student_groupsFuture[0]['CNT'] as int;
    if (student_groupCount != null) {
      student_groupCount(count);
    }
    return count;
  }

  /// This method returns List<Student_group> [Student_group]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Student_group>
  @override
  Future<List<Student_group>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Student_group> student_groupsData =
        await Student_group.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return student_groupsData;
  }

  /// This method returns Json String [Student_group]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Student_group]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Student_group]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnStudent_group!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Student_group]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM student_group WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnStudent_group!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Student_group]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnStudent_group!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Student_group.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnStudent_group!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Student_groupFilterBuilder

// region Student_groupFields
class Student_groupFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fFull_name;
  static TableField get full_name {
    return _fFull_name = _fFull_name ??
        SqlSyntax.setField(_fFull_name, 'full_name', DbType.text);
  }

  static TableField? _fAdmission_date;
  static TableField get admission_date {
    return _fAdmission_date = _fAdmission_date ??
        SqlSyntax.setField(_fAdmission_date, 'admission_date', DbType.date);
  }

  static TableField? _fVersion;
  static TableField get version {
    return _fVersion =
        _fVersion ?? SqlSyntax.setField(_fVersion, 'version', DbType.integer);
  }
}
// endregion Student_groupFields

//region Student_groupManager
class Student_groupManager extends SqfEntityProvider {
  Student_groupManager()
      : super(ElectronicRecordCardDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'student_group';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion Student_groupManager
// region Subject
class Subject extends TableBase {
  Subject({this.id, this.name, this.version}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Subject.withFields(this.id, this.name, this.version) {
    _setDefaultValues();
  }
  Subject.withId(this.id, this.name, this.version) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Subject.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['version'] != null) {
      version = int.tryParse(o['version'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Subject)
  int? id;
  String? name;
  int? version;
  bool? isSaved;
  // end FIELDS (Subject)

// COLLECTIONS & VIRTUALS (Subject)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plUser_subject_control_types', 'plField2'..]) or so on..
  List<User_subject_control_type>? plUser_subject_control_types;

  /// get User_subject_control_type(s) filtered by id=subject_id
  User_subject_control_typeFilterBuilder? getUser_subject_control_types(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return User_subject_control_type()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .subject_id
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Subject)

  static const bool _softDeleteActivated = false;
  SubjectManager? __mnSubject;

  SubjectManager get _mnSubject {
    return __mnSubject = __mnSubject ?? SubjectManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (version != null || !forView) {
      map['version'] = version;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (version != null || !forView) {
      map['version'] = version;
    }

// COLLECTIONS (Subject)
    if (!forQuery) {
      map['User_subject_control_types'] =
          await getUser_subject_control_types()!.toMapList();
    }
// END COLLECTIONS (Subject)

    return map;
  }

  /// This method returns Json String [Subject]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Subject]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [id, name, version];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, name, version];
  }

  static Future<List<Subject>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Subject.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Subject>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Subject>[];
    try {
      objList = list
          .map((subject) => Subject.fromMap(subject as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Subject.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Subject>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Subject> objList = <Subject>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Subject.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('subject.plUser_subject_control_types') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUser_subject_control_types'))) {
          /*_loadedfields!.add('subject.plUser_subject_control_types'); */ obj
                  .plUser_subject_control_types =
              obj.plUser_subject_control_types ??
                  await obj.getUser_subject_control_types()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Subject by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Subject] if exist, otherwise returns null
  Future<Subject?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Subject? obj;
    final data = await _mnSubject.getById([id]);
    if (data.length != 0) {
      obj = Subject.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('subject.plUser_subject_control_types') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUser_subject_control_types'))) {
          /*_loadedfields!.add('subject.plUser_subject_control_types'); */ obj
                  .plUser_subject_control_types =
              obj.plUser_subject_control_types ??
                  await obj.getUser_subject_control_types()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Subject) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSubject.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnSubject.update(this);
    }

    return id;
  }

  /// Saves the (Subject) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnSubject.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSubject.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<Subject> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Subject> subjects,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ElectronicRecordCardDbModel().batchStart();
    for (final obj in subjects) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await ElectronicRecordCardDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSubject.rawInsert(
          'INSERT OR REPLACE INTO subject (id, name, version)  VALUES (?,?,?)',
          [id, name, version],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Subject id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Subject id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Subject Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Subject>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Subject> subjects,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnSubject.rawInsertAll(
        'INSERT OR REPLACE INTO subject (id, name, version)  VALUES (?,?,?)',
        subjects,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Subject

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Subject invoked (id=$id)');
    if (await User_subject_control_type()
            .select()
            .subject_id
            .equals(id)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (User_subject_control_type.subject_id)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnSubject
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSubject.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Subject] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SubjectFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SubjectFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SubjectFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SubjectFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion subject

// region SubjectField
class SubjectField extends FilterBase {
  SubjectField(SubjectFilterBuilder subjectFB) : super(subjectFB);

  @override
  SubjectFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SubjectFilterBuilder;
  }

  @override
  SubjectFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SubjectFilterBuilder;
  }

  @override
  SubjectFilterBuilder isNull() {
    return super.isNull() as SubjectFilterBuilder;
  }

  @override
  SubjectFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SubjectFilterBuilder;
  }

  @override
  SubjectFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SubjectFilterBuilder;
  }

  @override
  SubjectFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SubjectFilterBuilder;
  }

  @override
  SubjectFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SubjectFilterBuilder;
  }

  @override
  SubjectFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SubjectFilterBuilder;
  }

  @override
  SubjectFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SubjectFilterBuilder;
  }

  @override
  SubjectFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as SubjectFilterBuilder;
  }

  @override
  SubjectFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SubjectFilterBuilder;
  }

  @override
  SubjectFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SubjectFilterBuilder;
  }

  @override
  SubjectField get not {
    return super.not as SubjectField;
  }
}
// endregion SubjectField

// region SubjectFilterBuilder
class SubjectFilterBuilder extends ConjunctionBase {
  SubjectFilterBuilder(Subject obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSubject = obj._mnSubject;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SubjectManager? _mnSubject;

  /// put the sql keyword 'AND'
  @override
  SubjectFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SubjectFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SubjectFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SubjectFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SubjectFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SubjectFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SubjectFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SubjectFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SubjectFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SubjectFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SubjectFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SubjectField _setField(SubjectField? field, String colName, DbType dbtype) {
    return SubjectField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SubjectField? _id;
  SubjectField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SubjectField? _name;
  SubjectField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  SubjectField? _version;
  SubjectField get version {
    return _version = _setField(_version, 'version', DbType.integer);
  }

  /// Deletes List<Subject> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (User_subject_control_type) according to DeleteRule.NO_ACTION

    final idListUser_subject_control_typeBYsubject_id =
        toListPrimaryKeySQL(false);
    final resUser_subject_control_typeBYsubject_id =
        await User_subject_control_type()
            .select()
            .where(
                'subject_id IN (${idListUser_subject_control_typeBYsubject_id['sql']})',
                parameterValue:
                    idListUser_subject_control_typeBYsubject_id['args'])
            .toCount();
    if (resUser_subject_control_typeBYsubject_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (User_subject_control_type.subject_id)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSubject!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSubject!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from subject ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSubject!.updateBatch(qparams, values);
  }

  /// This method always returns [Subject] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Subject?
  @override
  Future<Subject?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSubject!.toList(qparams);
    final data = await objFuture;
    Subject? obj;
    if (data.isNotEmpty) {
      obj = Subject.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('subject.plUser_subject_control_types') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUser_subject_control_types'))) {
          /*_loadedfields!.add('subject.plUser_subject_control_types'); */ obj
                  .plUser_subject_control_types =
              obj.plUser_subject_control_types ??
                  await obj.getUser_subject_control_types()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Subject]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Subject?
  @override
  Future<Subject> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Subject();
  }

  /// This method returns int. [Subject]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? subjectCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final subjectsFuture = await _mnSubject!.toList(qparams);
    final int count = subjectsFuture[0]['CNT'] as int;
    if (subjectCount != null) {
      subjectCount(count);
    }
    return count;
  }

  /// This method returns List<Subject> [Subject]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Subject>
  @override
  Future<List<Subject>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Subject> subjectsData = await Subject.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return subjectsData;
  }

  /// This method returns Json String [Subject]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Subject]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Subject]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSubject!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Subject]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM subject WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSubject!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Subject]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSubject!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Subject.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSubject!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SubjectFilterBuilder

// region SubjectFields
class SubjectFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fVersion;
  static TableField get version {
    return _fVersion =
        _fVersion ?? SqlSyntax.setField(_fVersion, 'version', DbType.integer);
  }
}
// endregion SubjectFields

//region SubjectManager
class SubjectManager extends SqfEntityProvider {
  SubjectManager()
      : super(ElectronicRecordCardDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'subject';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SubjectManager
// region Mark
class Mark extends TableBase {
  Mark({this.id, this.name, this.title, this.value, this.version}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Mark.withFields(this.id, this.name, this.title, this.value, this.version) {
    _setDefaultValues();
  }
  Mark.withId(this.id, this.name, this.title, this.value, this.version) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Mark.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['title'] != null) {
      title = o['title'].toString();
    }
    if (o['value'] != null) {
      value = int.tryParse(o['value'].toString());
    }
    if (o['version'] != null) {
      version = int.tryParse(o['version'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Mark)
  int? id;
  String? name;
  String? title;
  int? value;
  int? version;
  bool? isSaved;
  // end FIELDS (Mark)

// COLLECTIONS & VIRTUALS (Mark)
  ///(RelationType.MANY_TO_MANY) (mark_control_type) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plControl_types', 'plField2'..]) or so on..
  List<Control_type>? plControl_types;

  /// get Control_type(s) filtered by control_typeId IN mark_control_type
  Control_typeFilterBuilder? getControl_types(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Control_type()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT control_typeId FROM mark_control_type WHERE markId=?)',
            parameterValue: id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plStudent_marks', 'plField2'..]) or so on..
  List<Student_mark>? plStudent_marks;

  /// get Student_mark(s) filtered by id=mark_id
  Student_markFilterBuilder? getStudent_marks(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Student_mark()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .mark_id
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Mark)

  static const bool _softDeleteActivated = false;
  MarkManager? __mnMark;

  MarkManager get _mnMark {
    return __mnMark = __mnMark ?? MarkManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (value != null || !forView) {
      map['value'] = value;
    }
    if (version != null || !forView) {
      map['version'] = version;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (value != null || !forView) {
      map['value'] = value;
    }
    if (version != null || !forView) {
      map['version'] = version;
    }

// COLLECTIONS (Mark)
    if (!forQuery) {
      map['Control_types'] = await getControl_types()!.toMapList();
    }
    if (!forQuery) {
      map['Student_marks'] = await getStudent_marks()!.toMapList();
    }
// END COLLECTIONS (Mark)

    return map;
  }

  /// This method returns Json String [Mark]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Mark]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [id, name, title, value, version];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, name, title, value, version];
  }

  static Future<List<Mark>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Mark.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Mark>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Mark>[];
    try {
      objList = list
          .map((mark) => Mark.fromMap(mark as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Mark.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Mark>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Mark> objList = <Mark>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Mark.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('mark.plControl_types') && */ (preloadFields ==
                null ||
            preloadFields.contains('plControl_types'))) {
          /*_loadedfields!.add('mark.plControl_types'); */ obj.plControl_types =
              obj.plControl_types ??
                  await obj.getControl_types()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('mark.plStudent_marks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plStudent_marks'))) {
          /*_loadedfields!.add('mark.plStudent_marks'); */ obj.plStudent_marks =
              obj.plStudent_marks ??
                  await obj.getStudent_marks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Mark by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Mark] if exist, otherwise returns null
  Future<Mark?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Mark? obj;
    final data = await _mnMark.getById([id]);
    if (data.length != 0) {
      obj = Mark.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('mark.plControl_types') && */ (preloadFields ==
                null ||
            preloadFields.contains('plControl_types'))) {
          /*_loadedfields!.add('mark.plControl_types'); */ obj.plControl_types =
              obj.plControl_types ??
                  await obj.getControl_types()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('mark.plStudent_marks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plStudent_marks'))) {
          /*_loadedfields!.add('mark.plStudent_marks'); */ obj.plStudent_marks =
              obj.plStudent_marks ??
                  await obj.getStudent_marks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Mark) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnMark.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnMark.update(this);
    }

    return id;
  }

  /// Saves the (Mark) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnMark.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnMark.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<Mark> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Mark> marks,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ElectronicRecordCardDbModel().batchStart();
    for (final obj in marks) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await ElectronicRecordCardDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnMark.rawInsert(
          'INSERT OR REPLACE INTO mark (id, name, title, value, version)  VALUES (?,?,?,?,?)',
          [id, name, title, value, version],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Mark id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Mark id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Mark Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Mark>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Mark> marks,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnMark.rawInsertAll(
        'INSERT OR REPLACE INTO mark (id, name, title, value, version)  VALUES (?,?,?,?,?)',
        marks,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Mark

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Mark invoked (id=$id)');
    if (await Student_mark().select().mark_id.equals(id).and.toCount() > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Student_mark.mark_id)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnMark
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnMark.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Mark] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  MarkFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return MarkFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  MarkFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return MarkFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion mark

// region MarkField
class MarkField extends FilterBase {
  MarkField(MarkFilterBuilder markFB) : super(markFB);

  @override
  MarkFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as MarkFilterBuilder;
  }

  @override
  MarkFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as MarkFilterBuilder;
  }

  @override
  MarkFilterBuilder isNull() {
    return super.isNull() as MarkFilterBuilder;
  }

  @override
  MarkFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as MarkFilterBuilder;
  }

  @override
  MarkFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as MarkFilterBuilder;
  }

  @override
  MarkFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as MarkFilterBuilder;
  }

  @override
  MarkFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as MarkFilterBuilder;
  }

  @override
  MarkFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as MarkFilterBuilder;
  }

  @override
  MarkFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as MarkFilterBuilder;
  }

  @override
  MarkFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as MarkFilterBuilder;
  }

  @override
  MarkFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as MarkFilterBuilder;
  }

  @override
  MarkFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as MarkFilterBuilder;
  }

  @override
  MarkField get not {
    return super.not as MarkField;
  }
}
// endregion MarkField

// region MarkFilterBuilder
class MarkFilterBuilder extends ConjunctionBase {
  MarkFilterBuilder(Mark obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnMark = obj._mnMark;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  MarkManager? _mnMark;

  /// put the sql keyword 'AND'
  @override
  MarkFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  MarkFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  MarkFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  MarkFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  MarkFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  MarkFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  MarkFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  MarkFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  MarkFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  MarkFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  MarkFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  MarkField _setField(MarkField? field, String colName, DbType dbtype) {
    return MarkField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  MarkField? _id;
  MarkField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  MarkField? _name;
  MarkField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  MarkField? _title;
  MarkField get title {
    return _title = _setField(_title, 'title', DbType.text);
  }

  MarkField? _value;
  MarkField get value {
    return _value = _setField(_value, 'value', DbType.integer);
  }

  MarkField? _version;
  MarkField get version {
    return _version = _setField(_version, 'version', DbType.integer);
  }

  /// Deletes List<Mark> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (Student_mark) according to DeleteRule.NO_ACTION

    final idListStudent_markBYmark_id = toListPrimaryKeySQL(false);
    final resStudent_markBYmark_id = await Student_mark()
        .select()
        .where('mark_id IN (${idListStudent_markBYmark_id['sql']})',
            parameterValue: idListStudent_markBYmark_id['args'])
        .toCount();
    if (resStudent_markBYmark_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Student_mark.mark_id)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnMark!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnMark!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from mark ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnMark!.updateBatch(qparams, values);
  }

  /// This method always returns [Mark] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Mark?
  @override
  Future<Mark?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnMark!.toList(qparams);
    final data = await objFuture;
    Mark? obj;
    if (data.isNotEmpty) {
      obj = Mark.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('mark.plControl_types') && */ (preloadFields ==
                null ||
            preloadFields.contains('plControl_types'))) {
          /*_loadedfields!.add('mark.plControl_types'); */ obj.plControl_types =
              obj.plControl_types ??
                  await obj.getControl_types()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('mark.plStudent_marks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plStudent_marks'))) {
          /*_loadedfields!.add('mark.plStudent_marks'); */ obj.plStudent_marks =
              obj.plStudent_marks ??
                  await obj.getStudent_marks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Mark]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Mark?
  @override
  Future<Mark> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Mark();
  }

  /// This method returns int. [Mark]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? markCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final marksFuture = await _mnMark!.toList(qparams);
    final int count = marksFuture[0]['CNT'] as int;
    if (markCount != null) {
      markCount(count);
    }
    return count;
  }

  /// This method returns List<Mark> [Mark]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Mark>
  @override
  Future<List<Mark>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Mark> marksData = await Mark.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return marksData;
  }

  /// This method returns Json String [Mark]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Mark]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Mark]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnMark!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Mark]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM mark WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnMark!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Mark]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnMark!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Mark.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnMark!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion MarkFilterBuilder

// region MarkFields
class MarkFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fTitle;
  static TableField get title {
    return _fTitle =
        _fTitle ?? SqlSyntax.setField(_fTitle, 'title', DbType.text);
  }

  static TableField? _fValue;
  static TableField get value {
    return _fValue =
        _fValue ?? SqlSyntax.setField(_fValue, 'value', DbType.integer);
  }

  static TableField? _fVersion;
  static TableField get version {
    return _fVersion =
        _fVersion ?? SqlSyntax.setField(_fVersion, 'version', DbType.integer);
  }
}
// endregion MarkFields

//region MarkManager
class MarkManager extends SqfEntityProvider {
  MarkManager()
      : super(ElectronicRecordCardDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'mark';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion MarkManager
// region Control_type
class Control_type extends TableBase {
  Control_type({this.id, this.name, this.title, this.version}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Control_type.withFields(this.id, this.name, this.title, this.version) {
    _setDefaultValues();
  }
  Control_type.withId(this.id, this.name, this.title, this.version) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Control_type.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['title'] != null) {
      title = o['title'].toString();
    }
    if (o['version'] != null) {
      version = int.tryParse(o['version'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Control_type)
  int? id;
  String? name;
  String? title;
  int? version;
  bool? isSaved;
  // end FIELDS (Control_type)

// COLLECTIONS & VIRTUALS (Control_type)
  ///(RelationType.MANY_TO_MANY) (mark_control_type) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plMarks', 'plField2'..]) or so on..
  List<Mark>? plMarks;

  /// get Mark(s) filtered by markId IN mark_control_type
  MarkFilterBuilder? getMarks(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Mark()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'id IN (SELECT markId FROM mark_control_type WHERE control_typeId=?)',
            parameterValue: id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plUser_subject_control_types', 'plField2'..]) or so on..
  List<User_subject_control_type>? plUser_subject_control_types;

  /// get User_subject_control_type(s) filtered by id=control_type_id
  User_subject_control_typeFilterBuilder? getUser_subject_control_types(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return User_subject_control_type()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .control_type_id
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Control_type)

  static const bool _softDeleteActivated = false;
  Control_typeManager? __mnControl_type;

  Control_typeManager get _mnControl_type {
    return __mnControl_type = __mnControl_type ?? Control_typeManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (version != null || !forView) {
      map['version'] = version;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (version != null || !forView) {
      map['version'] = version;
    }

// COLLECTIONS (Control_type)
    if (!forQuery) {
      map['Marks'] = await getMarks()!.toMapList();
    }
    if (!forQuery) {
      map['User_subject_control_types'] =
          await getUser_subject_control_types()!.toMapList();
    }
// END COLLECTIONS (Control_type)

    return map;
  }

  /// This method returns Json String [Control_type]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Control_type]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [id, name, title, version];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, name, title, version];
  }

  static Future<List<Control_type>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Control_type.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Control_type>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Control_type>[];
    try {
      objList = list
          .map((control_type) =>
              Control_type.fromMap(control_type as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Control_type.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Control_type>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Control_type> objList = <Control_type>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Control_type.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('control_type.plMarks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plMarks'))) {
          /*_loadedfields!.add('control_type.plMarks'); */ obj.plMarks =
              obj.plMarks ??
                  await obj.getMarks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('control_type.plUser_subject_control_types') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUser_subject_control_types'))) {
          /*_loadedfields!.add('control_type.plUser_subject_control_types'); */ obj
                  .plUser_subject_control_types =
              obj.plUser_subject_control_types ??
                  await obj.getUser_subject_control_types()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Control_type by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Control_type] if exist, otherwise returns null
  Future<Control_type?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Control_type? obj;
    final data = await _mnControl_type.getById([id]);
    if (data.length != 0) {
      obj = Control_type.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('control_type.plMarks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plMarks'))) {
          /*_loadedfields!.add('control_type.plMarks'); */ obj.plMarks =
              obj.plMarks ??
                  await obj.getMarks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('control_type.plUser_subject_control_types') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUser_subject_control_types'))) {
          /*_loadedfields!.add('control_type.plUser_subject_control_types'); */ obj
                  .plUser_subject_control_types =
              obj.plUser_subject_control_types ??
                  await obj.getUser_subject_control_types()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Control_type) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnControl_type.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnControl_type.update(this);
    }

    return id;
  }

  /// Saves the (Control_type) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnControl_type.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnControl_type.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<Control_type> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Control_type> control_types,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ElectronicRecordCardDbModel().batchStart();
    for (final obj in control_types) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await ElectronicRecordCardDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnControl_type.rawInsert(
          'INSERT OR REPLACE INTO control_type (id, name, title, version)  VALUES (?,?,?,?)',
          [id, name, title, version],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Control_type id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Control_type id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Control_type Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Control_type>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Control_type> control_types,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnControl_type.rawInsertAll(
        'INSERT OR REPLACE INTO control_type (id, name, title, version)  VALUES (?,?,?,?)',
        control_types,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Control_type

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Control_type invoked (id=$id)');
    if (await User_subject_control_type()
            .select()
            .control_type_id
            .equals(id)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (User_subject_control_type.control_type_id)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnControl_type
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnControl_type.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Control_type] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Control_typeFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Control_typeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Control_typeFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Control_typeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion control_type

// region Control_typeField
class Control_typeField extends FilterBase {
  Control_typeField(Control_typeFilterBuilder control_typeFB)
      : super(control_typeFB);

  @override
  Control_typeFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Control_typeFilterBuilder;
  }

  @override
  Control_typeFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Control_typeFilterBuilder;
  }

  @override
  Control_typeFilterBuilder isNull() {
    return super.isNull() as Control_typeFilterBuilder;
  }

  @override
  Control_typeFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Control_typeFilterBuilder;
  }

  @override
  Control_typeFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Control_typeFilterBuilder;
  }

  @override
  Control_typeFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Control_typeFilterBuilder;
  }

  @override
  Control_typeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Control_typeFilterBuilder;
  }

  @override
  Control_typeFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Control_typeFilterBuilder;
  }

  @override
  Control_typeFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Control_typeFilterBuilder;
  }

  @override
  Control_typeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Control_typeFilterBuilder;
  }

  @override
  Control_typeFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Control_typeFilterBuilder;
  }

  @override
  Control_typeFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Control_typeFilterBuilder;
  }

  @override
  Control_typeField get not {
    return super.not as Control_typeField;
  }
}
// endregion Control_typeField

// region Control_typeFilterBuilder
class Control_typeFilterBuilder extends ConjunctionBase {
  Control_typeFilterBuilder(Control_type obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnControl_type = obj._mnControl_type;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Control_typeManager? _mnControl_type;

  /// put the sql keyword 'AND'
  @override
  Control_typeFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Control_typeFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Control_typeFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Control_typeFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Control_typeFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Control_typeFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Control_typeFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Control_typeFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Control_typeFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Control_typeFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Control_typeFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Control_typeField _setField(
      Control_typeField? field, String colName, DbType dbtype) {
    return Control_typeField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Control_typeField? _id;
  Control_typeField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  Control_typeField? _name;
  Control_typeField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  Control_typeField? _title;
  Control_typeField get title {
    return _title = _setField(_title, 'title', DbType.text);
  }

  Control_typeField? _version;
  Control_typeField get version {
    return _version = _setField(_version, 'version', DbType.integer);
  }

  /// Deletes List<Control_type> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (User_subject_control_type) according to DeleteRule.NO_ACTION

    final idListUser_subject_control_typeBYcontrol_type_id =
        toListPrimaryKeySQL(false);
    final resUser_subject_control_typeBYcontrol_type_id =
        await User_subject_control_type()
            .select()
            .where(
                'control_type_id IN (${idListUser_subject_control_typeBYcontrol_type_id['sql']})',
                parameterValue:
                    idListUser_subject_control_typeBYcontrol_type_id['args'])
            .toCount();
    if (resUser_subject_control_typeBYcontrol_type_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (User_subject_control_type.control_type_id)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnControl_type!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnControl_type!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from control_type ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnControl_type!.updateBatch(qparams, values);
  }

  /// This method always returns [Control_type] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Control_type?
  @override
  Future<Control_type?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnControl_type!.toList(qparams);
    final data = await objFuture;
    Control_type? obj;
    if (data.isNotEmpty) {
      obj = Control_type.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('control_type.plMarks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plMarks'))) {
          /*_loadedfields!.add('control_type.plMarks'); */ obj.plMarks =
              obj.plMarks ??
                  await obj.getMarks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('control_type.plUser_subject_control_types') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUser_subject_control_types'))) {
          /*_loadedfields!.add('control_type.plUser_subject_control_types'); */ obj
                  .plUser_subject_control_types =
              obj.plUser_subject_control_types ??
                  await obj.getUser_subject_control_types()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Control_type]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Control_type?
  @override
  Future<Control_type> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Control_type();
  }

  /// This method returns int. [Control_type]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? control_typeCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final control_typesFuture = await _mnControl_type!.toList(qparams);
    final int count = control_typesFuture[0]['CNT'] as int;
    if (control_typeCount != null) {
      control_typeCount(count);
    }
    return count;
  }

  /// This method returns List<Control_type> [Control_type]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Control_type>
  @override
  Future<List<Control_type>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Control_type> control_typesData = await Control_type.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return control_typesData;
  }

  /// This method returns Json String [Control_type]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Control_type]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Control_type]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnControl_type!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Control_type]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM control_type WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnControl_type!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Control_type]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnControl_type!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Control_type.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnControl_type!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Control_typeFilterBuilder

// region Control_typeFields
class Control_typeFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fTitle;
  static TableField get title {
    return _fTitle =
        _fTitle ?? SqlSyntax.setField(_fTitle, 'title', DbType.text);
  }

  static TableField? _fVersion;
  static TableField get version {
    return _fVersion =
        _fVersion ?? SqlSyntax.setField(_fVersion, 'version', DbType.integer);
  }
}
// endregion Control_typeFields

//region Control_typeManager
class Control_typeManager extends SqfEntityProvider {
  Control_typeManager()
      : super(ElectronicRecordCardDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'control_type';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion Control_typeManager
// region User
class User extends TableBase {
  User(
      {this.id,
      this.login,
      this.last_name,
      this.first_name,
      this.middle_name,
      this.record_book_number,
      this.version,
      this.groupId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  User.withFields(this.id, this.login, this.last_name, this.first_name,
      this.middle_name, this.record_book_number, this.version, this.groupId) {
    _setDefaultValues();
  }
  User.withId(this.id, this.login, this.last_name, this.first_name,
      this.middle_name, this.record_book_number, this.version, this.groupId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  User.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['login'] != null) {
      login = o['login'].toString();
    }
    if (o['last_name'] != null) {
      last_name = o['last_name'].toString();
    }
    if (o['first_name'] != null) {
      first_name = o['first_name'].toString();
    }
    if (o['middle_name'] != null) {
      middle_name = o['middle_name'].toString();
    }
    if (o['record_book_number'] != null) {
      record_book_number = o['record_book_number'].toString();
    }
    if (o['version'] != null) {
      version = int.tryParse(o['version'].toString());
    }
    groupId = int.tryParse(o['groupId'].toString());

    // RELATIONSHIPS FromMAP
    plStudent_group = o['student_group'] != null
        ? Student_group.fromMap(o['student_group'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (User)
  int? id;
  String? login;
  String? last_name;
  String? first_name;
  String? middle_name;
  String? record_book_number;
  int? version;
  int? groupId;
  bool? isSaved;
  // end FIELDS (User)

// RELATIONSHIPS (User)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plStudent_group', 'plField2'..]) or so on..
  Student_group? plStudent_group;

  /// get Student_group By GroupId
  Future<Student_group?> getStudent_group(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Student_group()
        .getById(groupId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (User)

// COLLECTIONS & VIRTUALS (User)
  ///(RelationType.MANY_TO_MANY) (user_role) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plRoles', 'plField2'..]) or so on..
  List<Role>? plRoles;

  /// get Role(s) filtered by roleId IN user_role
  RoleFilterBuilder? getRoles(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Role()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where('id IN (SELECT roleId FROM user_role WHERE userId=?)',
            parameterValue: id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plUser_subject_control_types', 'plField2'..]) or so on..
  List<User_subject_control_type>? plUser_subject_control_types;

  /// get User_subject_control_type(s) filtered by id=teacher_id
  User_subject_control_typeFilterBuilder? getUser_subject_control_types(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return User_subject_control_type()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .teacher_id
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plUser_subject_control_typesBystudent_id', 'plField2'..]) or so on..
  List<User_subject_control_type>? plUser_subject_control_typesBystudent_id;

  /// get User_subject_control_type(s) filtered by id=student_id
  User_subject_control_typeFilterBuilder?
      getUser_subject_control_typesBystudent_id(
          {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return User_subject_control_type()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .student_id
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (User)

  static const bool _softDeleteActivated = false;
  UserManager? __mnUser;

  UserManager get _mnUser {
    return __mnUser = __mnUser ?? UserManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (login != null || !forView) {
      map['login'] = login;
    }
    if (last_name != null || !forView) {
      map['last_name'] = last_name;
    }
    if (first_name != null || !forView) {
      map['first_name'] = first_name;
    }
    if (middle_name != null || !forView) {
      map['middle_name'] = middle_name;
    }
    if (record_book_number != null || !forView) {
      map['record_book_number'] = record_book_number;
    }
    if (version != null || !forView) {
      map['version'] = version;
    }
    if (groupId != null) {
      map['groupId'] = forView
          ? plStudent_group == null
              ? groupId
              : plStudent_group!.name
          : groupId;
    } else if (groupId != null || !forView) {
      map['groupId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (login != null || !forView) {
      map['login'] = login;
    }
    if (last_name != null || !forView) {
      map['last_name'] = last_name;
    }
    if (first_name != null || !forView) {
      map['first_name'] = first_name;
    }
    if (middle_name != null || !forView) {
      map['middle_name'] = middle_name;
    }
    if (record_book_number != null || !forView) {
      map['record_book_number'] = record_book_number;
    }
    if (version != null || !forView) {
      map['version'] = version;
    }
    if (groupId != null) {
      map['groupId'] = forView
          ? plStudent_group == null
              ? groupId
              : plStudent_group!.name
          : groupId;
    } else if (groupId != null || !forView) {
      map['groupId'] = null;
    }

// COLLECTIONS (User)
    if (!forQuery) {
      map['Roles'] = await getRoles()!.toMapList();
    }
    if (!forQuery) {
      map['User_subject_control_types'] =
          await getUser_subject_control_types()!.toMapList();
    }
    if (!forQuery) {
      map['User_subject_control_types'] =
          await getUser_subject_control_types()!.toMapList();
    }
// END COLLECTIONS (User)

    return map;
  }

  /// This method returns Json String [User]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [User]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      id,
      login,
      last_name,
      first_name,
      middle_name,
      record_book_number,
      version,
      groupId
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      login,
      last_name,
      first_name,
      middle_name,
      record_book_number,
      version,
      groupId
    ];
  }

  static Future<List<User>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR User.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<User>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <User>[];
    try {
      objList = list
          .map((user) => User.fromMap(user as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR User.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<User>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<User> objList = <User>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = User.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('user.plRoles') && */ (preloadFields ==
                null ||
            preloadFields.contains('plRoles'))) {
          /*_loadedfields!.add('user.plRoles'); */ obj.plRoles = obj.plRoles ??
              await obj.getRoles()!.toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('user.plUser_subject_control_types') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUser_subject_control_types'))) {
          /*_loadedfields!.add('user.plUser_subject_control_types'); */ obj
                  .plUser_subject_control_types =
              obj.plUser_subject_control_types ??
                  await obj.getUser_subject_control_types()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('user.plUser_subject_control_typesBystudent_id') && */ (preloadFields ==
                null ||
            preloadFields
                .contains('plUser_subject_control_typesBystudent_id'))) {
          /*_loadedfields!.add('user.plUser_subject_control_typesBystudent_id'); */ obj
                  .plUser_subject_control_typesBystudent_id =
              obj.plUser_subject_control_typesBystudent_id ??
                  await obj.getUser_subject_control_typesBystudent_id()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plStudent_group'))) {
          obj.plStudent_group = obj.plStudent_group ??
              await obj.getStudent_group(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns User by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [User] if exist, otherwise returns null
  Future<User?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    User? obj;
    final data = await _mnUser.getById([id]);
    if (data.length != 0) {
      obj = User.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('user.plRoles') && */ (preloadFields ==
                null ||
            preloadFields.contains('plRoles'))) {
          /*_loadedfields!.add('user.plRoles'); */ obj.plRoles = obj.plRoles ??
              await obj.getRoles()!.toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('user.plUser_subject_control_types') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUser_subject_control_types'))) {
          /*_loadedfields!.add('user.plUser_subject_control_types'); */ obj
                  .plUser_subject_control_types =
              obj.plUser_subject_control_types ??
                  await obj.getUser_subject_control_types()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('user.plUser_subject_control_typesBystudent_id') && */ (preloadFields ==
                null ||
            preloadFields
                .contains('plUser_subject_control_typesBystudent_id'))) {
          /*_loadedfields!.add('user.plUser_subject_control_typesBystudent_id'); */ obj
                  .plUser_subject_control_typesBystudent_id =
              obj.plUser_subject_control_typesBystudent_id ??
                  await obj.getUser_subject_control_typesBystudent_id()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plStudent_group'))) {
          obj.plStudent_group = obj.plStudent_group ??
              await obj.getStudent_group(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (User) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnUser.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnUser.update(this);
    }

    return id;
  }

  /// Saves the (User) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnUser.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnUser.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<User> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<User> users,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ElectronicRecordCardDbModel().batchStart();
    for (final obj in users) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await ElectronicRecordCardDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnUser.rawInsert(
          'INSERT OR REPLACE INTO user (id, login, last_name, first_name, middle_name, record_book_number, version, groupId)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            login,
            last_name,
            first_name,
            middle_name,
            record_book_number,
            version,
            groupId
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'User id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'User id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'User Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<User>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<User> users,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnUser.rawInsertAll(
        'INSERT OR REPLACE INTO user (id, login, last_name, first_name, middle_name, record_book_number, version, groupId)  VALUES (?,?,?,?,?,?,?,?)',
        users,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes User

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete User invoked (id=$id)');
    if (await User_subject_control_type()
            .select()
            .teacher_id
            .equals(id)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (User_subject_control_type.teacher_id)');
    }
    if (await User_subject_control_type()
            .select()
            .student_id
            .equals(id)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (User_subject_control_type.student_id)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnUser
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnUser.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [User] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  UserFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UserFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  UserFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UserFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion user

// region UserField
class UserField extends FilterBase {
  UserField(UserFilterBuilder userFB) : super(userFB);

  @override
  UserFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder isNull() {
    return super.isNull() as UserFilterBuilder;
  }

  @override
  UserFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as UserFilterBuilder;
  }

  @override
  UserFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as UserFilterBuilder;
  }

  @override
  UserField get not {
    return super.not as UserField;
  }
}
// endregion UserField

// region UserFilterBuilder
class UserFilterBuilder extends ConjunctionBase {
  UserFilterBuilder(User obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnUser = obj._mnUser;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  UserManager? _mnUser;

  /// put the sql keyword 'AND'
  @override
  UserFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  UserFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  UserFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  UserFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  UserFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  UserFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  UserFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  UserFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  UserFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  UserFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  UserFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  UserField _setField(UserField? field, String colName, DbType dbtype) {
    return UserField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  UserField? _id;
  UserField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  UserField? _login;
  UserField get login {
    return _login = _setField(_login, 'login', DbType.text);
  }

  UserField? _last_name;
  UserField get last_name {
    return _last_name = _setField(_last_name, 'last_name', DbType.text);
  }

  UserField? _first_name;
  UserField get first_name {
    return _first_name = _setField(_first_name, 'first_name', DbType.text);
  }

  UserField? _middle_name;
  UserField get middle_name {
    return _middle_name = _setField(_middle_name, 'middle_name', DbType.text);
  }

  UserField? _record_book_number;
  UserField get record_book_number {
    return _record_book_number =
        _setField(_record_book_number, 'record_book_number', DbType.text);
  }

  UserField? _version;
  UserField get version {
    return _version = _setField(_version, 'version', DbType.integer);
  }

  UserField? _groupId;
  UserField get groupId {
    return _groupId = _setField(_groupId, 'groupId', DbType.integer);
  }

  /// Deletes List<User> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (User_subject_control_type) according to DeleteRule.NO_ACTION

    final idListUser_subject_control_typeBYteacher_id =
        toListPrimaryKeySQL(false);
    final resUser_subject_control_typeBYteacher_id =
        await User_subject_control_type()
            .select()
            .where(
                'teacher_id IN (${idListUser_subject_control_typeBYteacher_id['sql']})',
                parameterValue:
                    idListUser_subject_control_typeBYteacher_id['args'])
            .toCount();
    if (resUser_subject_control_typeBYteacher_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (User_subject_control_type.teacher_id)');
    }
// Check sub records where in (User_subject_control_type) according to DeleteRule.NO_ACTION

    final idListUser_subject_control_typeBYstudent_id =
        toListPrimaryKeySQL(false);
    final resUser_subject_control_typeBYstudent_id =
        await User_subject_control_type()
            .select()
            .where(
                'student_id IN (${idListUser_subject_control_typeBYstudent_id['sql']})',
                parameterValue:
                    idListUser_subject_control_typeBYstudent_id['args'])
            .toCount();
    if (resUser_subject_control_typeBYstudent_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (User_subject_control_type.student_id)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnUser!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnUser!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from user ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnUser!.updateBatch(qparams, values);
  }

  /// This method always returns [User] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> User?
  @override
  Future<User?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnUser!.toList(qparams);
    final data = await objFuture;
    User? obj;
    if (data.isNotEmpty) {
      obj = User.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('user.plRoles') && */ (preloadFields ==
                null ||
            preloadFields.contains('plRoles'))) {
          /*_loadedfields!.add('user.plRoles'); */ obj.plRoles = obj.plRoles ??
              await obj.getRoles()!.toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('user.plUser_subject_control_types') && */ (preloadFields ==
                null ||
            preloadFields.contains('plUser_subject_control_types'))) {
          /*_loadedfields!.add('user.plUser_subject_control_types'); */ obj
                  .plUser_subject_control_types =
              obj.plUser_subject_control_types ??
                  await obj.getUser_subject_control_types()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('user.plUser_subject_control_typesBystudent_id') && */ (preloadFields ==
                null ||
            preloadFields
                .contains('plUser_subject_control_typesBystudent_id'))) {
          /*_loadedfields!.add('user.plUser_subject_control_typesBystudent_id'); */ obj
                  .plUser_subject_control_typesBystudent_id =
              obj.plUser_subject_control_typesBystudent_id ??
                  await obj.getUser_subject_control_typesBystudent_id()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plStudent_group'))) {
          obj.plStudent_group = obj.plStudent_group ??
              await obj.getStudent_group(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [User]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> User?
  @override
  Future<User> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        User();
  }

  /// This method returns int. [User]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? userCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final usersFuture = await _mnUser!.toList(qparams);
    final int count = usersFuture[0]['CNT'] as int;
    if (userCount != null) {
      userCount(count);
    }
    return count;
  }

  /// This method returns List<User> [User]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<User>
  @override
  Future<List<User>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<User> usersData = await User.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return usersData;
  }

  /// This method returns Json String [User]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [User]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [User]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnUser!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [User]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM user WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnUser!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [User]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnUser!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await User.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnUser!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion UserFilterBuilder

// region UserFields
class UserFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fLogin;
  static TableField get login {
    return _fLogin =
        _fLogin ?? SqlSyntax.setField(_fLogin, 'login', DbType.text);
  }

  static TableField? _fLast_name;
  static TableField get last_name {
    return _fLast_name = _fLast_name ??
        SqlSyntax.setField(_fLast_name, 'last_name', DbType.text);
  }

  static TableField? _fFirst_name;
  static TableField get first_name {
    return _fFirst_name = _fFirst_name ??
        SqlSyntax.setField(_fFirst_name, 'first_name', DbType.text);
  }

  static TableField? _fMiddle_name;
  static TableField get middle_name {
    return _fMiddle_name = _fMiddle_name ??
        SqlSyntax.setField(_fMiddle_name, 'middle_name', DbType.text);
  }

  static TableField? _fRecord_book_number;
  static TableField get record_book_number {
    return _fRecord_book_number = _fRecord_book_number ??
        SqlSyntax.setField(
            _fRecord_book_number, 'record_book_number', DbType.text);
  }

  static TableField? _fVersion;
  static TableField get version {
    return _fVersion =
        _fVersion ?? SqlSyntax.setField(_fVersion, 'version', DbType.integer);
  }

  static TableField? _fGroupId;
  static TableField get groupId {
    return _fGroupId =
        _fGroupId ?? SqlSyntax.setField(_fGroupId, 'groupId', DbType.integer);
  }
}
// endregion UserFields

//region UserManager
class UserManager extends SqfEntityProvider {
  UserManager()
      : super(ElectronicRecordCardDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'user';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion UserManager
// region User_subject_control_type
class User_subject_control_type extends TableBase {
  User_subject_control_type(
      {this.id,
      this.semester,
      this.hours_number,
      this.version,
      this.teacher_id,
      this.subject_id,
      this.control_type_id,
      this.student_id}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  User_subject_control_type.withFields(
      this.id,
      this.semester,
      this.hours_number,
      this.version,
      this.teacher_id,
      this.subject_id,
      this.control_type_id,
      this.student_id) {
    _setDefaultValues();
  }
  User_subject_control_type.withId(
      this.id,
      this.semester,
      this.hours_number,
      this.version,
      this.teacher_id,
      this.subject_id,
      this.control_type_id,
      this.student_id) {
    _setDefaultValues();
  }
  // fromMap v2.0
  User_subject_control_type.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['semester'] != null) {
      semester = int.tryParse(o['semester'].toString());
    }
    if (o['hours_number'] != null) {
      hours_number = int.tryParse(o['hours_number'].toString());
    }
    if (o['version'] != null) {
      version = int.tryParse(o['version'].toString());
    }
    teacher_id = int.tryParse(o['teacher_id'].toString());

    subject_id = int.tryParse(o['subject_id'].toString());

    control_type_id = int.tryParse(o['control_type_id'].toString());

    student_id = int.tryParse(o['student_id'].toString());

    // RELATIONSHIPS FromMAP
    plUser = o['user'] != null
        ? User.fromMap(o['user'] as Map<String, dynamic>)
        : null;
    plSubject = o['subject'] != null
        ? Subject.fromMap(o['subject'] as Map<String, dynamic>)
        : null;
    plControl_type = o['control_type'] != null
        ? Control_type.fromMap(o['control_type'] as Map<String, dynamic>)
        : null;
    plUserByStudent_id = o['user'] != null
        ? User.fromMap(o['user'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (User_subject_control_type)
  int? id;
  int? semester;
  int? hours_number;
  int? version;
  int? teacher_id;
  int? subject_id;
  int? control_type_id;
  int? student_id;
  bool? isSaved;
  // end FIELDS (User_subject_control_type)

// RELATIONSHIPS (User_subject_control_type)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plUser', 'plField2'..]) or so on..
  User? plUser;

  /// get User By Teacher_id
  Future<User?> getUser(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await User().getById(teacher_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSubject', 'plField2'..]) or so on..
  Subject? plSubject;

  /// get Subject By Subject_id
  Future<Subject?> getSubject(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Subject().getById(subject_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plControl_type', 'plField2'..]) or so on..
  Control_type? plControl_type;

  /// get Control_type By Control_type_id
  Future<Control_type?> getControl_type(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Control_type().getById(control_type_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plUserByStudent_id', 'plField2'..]) or so on..
  User? plUserByStudent_id;

  /// get User By Student_id
  Future<User?> getUserByStudent_id(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await User().getById(student_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (User_subject_control_type)

// COLLECTIONS & VIRTUALS (User_subject_control_type)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plStudent_marks', 'plField2'..]) or so on..
  List<Student_mark>? plStudent_marks;

  /// get Student_mark(s) filtered by id=user_subject_control_type_id
  Student_markFilterBuilder? getStudent_marks(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Student_mark()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .user_subject_control_type_id
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (User_subject_control_type)

  static const bool _softDeleteActivated = false;
  User_subject_control_typeManager? __mnUser_subject_control_type;

  User_subject_control_typeManager get _mnUser_subject_control_type {
    return __mnUser_subject_control_type =
        __mnUser_subject_control_type ?? User_subject_control_typeManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (semester != null || !forView) {
      map['semester'] = semester;
    }
    if (hours_number != null || !forView) {
      map['hours_number'] = hours_number;
    }
    if (version != null || !forView) {
      map['version'] = version;
    }
    if (teacher_id != null) {
      map['teacher_id'] = forView
          ? plUser == null
              ? teacher_id
              : plUser!.login
          : teacher_id;
    } else if (teacher_id != null || !forView) {
      map['teacher_id'] = null;
    }
    if (subject_id != null) {
      map['subject_id'] = forView
          ? plSubject == null
              ? subject_id
              : plSubject!.name
          : subject_id;
    } else if (subject_id != null || !forView) {
      map['subject_id'] = null;
    }
    if (control_type_id != null) {
      map['control_type_id'] = forView
          ? plControl_type == null
              ? control_type_id
              : plControl_type!.name
          : control_type_id;
    } else if (control_type_id != null || !forView) {
      map['control_type_id'] = null;
    }
    if (student_id != null) {
      map['student_id'] = forView
          ? plUser == null
              ? student_id
              : plUser!.login
          : student_id;
    } else if (student_id != null || !forView) {
      map['student_id'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (semester != null || !forView) {
      map['semester'] = semester;
    }
    if (hours_number != null || !forView) {
      map['hours_number'] = hours_number;
    }
    if (version != null || !forView) {
      map['version'] = version;
    }
    if (teacher_id != null) {
      map['teacher_id'] = forView
          ? plUser == null
              ? teacher_id
              : plUser!.login
          : teacher_id;
    } else if (teacher_id != null || !forView) {
      map['teacher_id'] = null;
    }
    if (subject_id != null) {
      map['subject_id'] = forView
          ? plSubject == null
              ? subject_id
              : plSubject!.name
          : subject_id;
    } else if (subject_id != null || !forView) {
      map['subject_id'] = null;
    }
    if (control_type_id != null) {
      map['control_type_id'] = forView
          ? plControl_type == null
              ? control_type_id
              : plControl_type!.name
          : control_type_id;
    } else if (control_type_id != null || !forView) {
      map['control_type_id'] = null;
    }
    if (student_id != null) {
      map['student_id'] = forView
          ? plUser == null
              ? student_id
              : plUser!.login
          : student_id;
    } else if (student_id != null || !forView) {
      map['student_id'] = null;
    }

// COLLECTIONS (User_subject_control_type)
    if (!forQuery) {
      map['Student_marks'] = await getStudent_marks()!.toMapList();
    }
// END COLLECTIONS (User_subject_control_type)

    return map;
  }

  /// This method returns Json String [User_subject_control_type]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [User_subject_control_type]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      id,
      semester,
      hours_number,
      version,
      teacher_id,
      subject_id,
      control_type_id,
      student_id
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      semester,
      hours_number,
      version,
      teacher_id,
      subject_id,
      control_type_id,
      student_id
    ];
  }

  static Future<List<User_subject_control_type>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR User_subject_control_type.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<User_subject_control_type>> fromJson(
      String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <User_subject_control_type>[];
    try {
      objList = list
          .map((user_subject_control_type) => User_subject_control_type.fromMap(
              user_subject_control_type as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR User_subject_control_type.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<User_subject_control_type>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<User_subject_control_type> objList =
        <User_subject_control_type>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = User_subject_control_type.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('user_subject_control_type.plStudent_marks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plStudent_marks'))) {
          /*_loadedfields!.add('user_subject_control_type.plStudent_marks'); */ obj
                  .plStudent_marks =
              obj.plStudent_marks ??
                  await obj.getStudent_marks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plUser'))) {
          obj.plUser =
              obj.plUser ?? await obj.getUser(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSubject'))) {
          obj.plSubject =
              obj.plSubject ?? await obj.getSubject(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plControl_type'))) {
          obj.plControl_type = obj.plControl_type ??
              await obj.getControl_type(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plUserByStudent_id'))) {
          obj.plUserByStudent_id = obj.plUserByStudent_id ??
              await obj.getUserByStudent_id(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns User_subject_control_type by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [User_subject_control_type] if exist, otherwise returns null
  Future<User_subject_control_type?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    User_subject_control_type? obj;
    final data = await _mnUser_subject_control_type.getById([id]);
    if (data.length != 0) {
      obj = User_subject_control_type.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('user_subject_control_type.plStudent_marks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plStudent_marks'))) {
          /*_loadedfields!.add('user_subject_control_type.plStudent_marks'); */ obj
                  .plStudent_marks =
              obj.plStudent_marks ??
                  await obj.getStudent_marks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plUser'))) {
          obj.plUser =
              obj.plUser ?? await obj.getUser(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSubject'))) {
          obj.plSubject =
              obj.plSubject ?? await obj.getSubject(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plControl_type'))) {
          obj.plControl_type = obj.plControl_type ??
              await obj.getControl_type(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plUserByStudent_id'))) {
          obj.plUserByStudent_id = obj.plUserByStudent_id ??
              await obj.getUserByStudent_id(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (User_subject_control_type) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnUser_subject_control_type.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnUser_subject_control_type.update(this);
    }

    return id;
  }

  /// Saves the (User_subject_control_type) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnUser_subject_control_type.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnUser_subject_control_type.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<User_subject_control_type> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<User_subject_control_type> user_subject_control_types,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ElectronicRecordCardDbModel().batchStart();
    for (final obj in user_subject_control_types) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await ElectronicRecordCardDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnUser_subject_control_type.rawInsert(
          'INSERT OR REPLACE INTO user_subject_control_type (id, semester, hours_number, version, teacher_id, subject_id, control_type_id, student_id)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            semester,
            hours_number,
            version,
            teacher_id,
            subject_id,
            control_type_id,
            student_id
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'User_subject_control_type id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'User_subject_control_type id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'User_subject_control_type Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<User_subject_control_type>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<User_subject_control_type> user_subject_control_types,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    final results = await _mnUser_subject_control_type.rawInsertAll(
        'INSERT OR REPLACE INTO user_subject_control_type (id, semester, hours_number, version, teacher_id, subject_id, control_type_id, student_id)  VALUES (?,?,?,?,?,?,?,?)',
        user_subject_control_types,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes User_subject_control_type

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete User_subject_control_type invoked (id=$id)');
    if (await Student_mark()
            .select()
            .user_subject_control_type_id
            .equals(id)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Student_mark.user_subject_control_type_id)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnUser_subject_control_type
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnUser_subject_control_type.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [User_subject_control_type] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  User_subject_control_typeFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return User_subject_control_typeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  User_subject_control_typeFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return User_subject_control_typeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion user_subject_control_type

// region User_subject_control_typeField
class User_subject_control_typeField extends FilterBase {
  User_subject_control_typeField(
      User_subject_control_typeFilterBuilder user_subject_control_typeFB)
      : super(user_subject_control_typeFB);

  @override
  User_subject_control_typeFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as User_subject_control_typeFilterBuilder;
  }

  @override
  User_subject_control_typeFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as User_subject_control_typeFilterBuilder;
  }

  @override
  User_subject_control_typeFilterBuilder isNull() {
    return super.isNull() as User_subject_control_typeFilterBuilder;
  }

  @override
  User_subject_control_typeFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as User_subject_control_typeFilterBuilder;
  }

  @override
  User_subject_control_typeFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as User_subject_control_typeFilterBuilder;
  }

  @override
  User_subject_control_typeFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as User_subject_control_typeFilterBuilder;
  }

  @override
  User_subject_control_typeFilterBuilder between(
      dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast)
        as User_subject_control_typeFilterBuilder;
  }

  @override
  User_subject_control_typeFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as User_subject_control_typeFilterBuilder;
  }

  @override
  User_subject_control_typeFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as User_subject_control_typeFilterBuilder;
  }

  @override
  User_subject_control_typeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as User_subject_control_typeFilterBuilder;
  }

  @override
  User_subject_control_typeFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue)
        as User_subject_control_typeFilterBuilder;
  }

  @override
  User_subject_control_typeFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as User_subject_control_typeFilterBuilder;
  }

  @override
  User_subject_control_typeField get not {
    return super.not as User_subject_control_typeField;
  }
}
// endregion User_subject_control_typeField

// region User_subject_control_typeFilterBuilder
class User_subject_control_typeFilterBuilder extends ConjunctionBase {
  User_subject_control_typeFilterBuilder(
      User_subject_control_type obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnUser_subject_control_type = obj._mnUser_subject_control_type;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  User_subject_control_typeManager? _mnUser_subject_control_type;

  /// put the sql keyword 'AND'
  @override
  User_subject_control_typeFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  User_subject_control_typeFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  User_subject_control_typeFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  User_subject_control_typeFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  User_subject_control_typeFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  User_subject_control_typeFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  User_subject_control_typeFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  User_subject_control_typeFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  User_subject_control_typeFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  User_subject_control_typeFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  User_subject_control_typeFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  User_subject_control_typeField _setField(
      User_subject_control_typeField? field, String colName, DbType dbtype) {
    return User_subject_control_typeField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  User_subject_control_typeField? _id;
  User_subject_control_typeField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  User_subject_control_typeField? _semester;
  User_subject_control_typeField get semester {
    return _semester = _setField(_semester, 'semester', DbType.integer);
  }

  User_subject_control_typeField? _hours_number;
  User_subject_control_typeField get hours_number {
    return _hours_number =
        _setField(_hours_number, 'hours_number', DbType.integer);
  }

  User_subject_control_typeField? _version;
  User_subject_control_typeField get version {
    return _version = _setField(_version, 'version', DbType.integer);
  }

  User_subject_control_typeField? _teacher_id;
  User_subject_control_typeField get teacher_id {
    return _teacher_id = _setField(_teacher_id, 'teacher_id', DbType.integer);
  }

  User_subject_control_typeField? _subject_id;
  User_subject_control_typeField get subject_id {
    return _subject_id = _setField(_subject_id, 'subject_id', DbType.integer);
  }

  User_subject_control_typeField? _control_type_id;
  User_subject_control_typeField get control_type_id {
    return _control_type_id =
        _setField(_control_type_id, 'control_type_id', DbType.integer);
  }

  User_subject_control_typeField? _student_id;
  User_subject_control_typeField get student_id {
    return _student_id = _setField(_student_id, 'student_id', DbType.integer);
  }

  /// Deletes List<User_subject_control_type> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (Student_mark) according to DeleteRule.NO_ACTION

    final idListStudent_markBYuser_subject_control_type_id =
        toListPrimaryKeySQL(false);
    final resStudent_markBYuser_subject_control_type_id = await Student_mark()
        .select()
        .where(
            'user_subject_control_type_id IN (${idListStudent_markBYuser_subject_control_type_id['sql']})',
            parameterValue:
                idListStudent_markBYuser_subject_control_type_id['args'])
        .toCount();
    if (resStudent_markBYuser_subject_control_type_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Student_mark.user_subject_control_type_id)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnUser_subject_control_type!
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnUser_subject_control_type!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from user_subject_control_type ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnUser_subject_control_type!.updateBatch(qparams, values);
  }

  /// This method always returns [User_subject_control_type] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> User_subject_control_type?
  @override
  Future<User_subject_control_type?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnUser_subject_control_type!.toList(qparams);
    final data = await objFuture;
    User_subject_control_type? obj;
    if (data.isNotEmpty) {
      obj = User_subject_control_type.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('user_subject_control_type.plStudent_marks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plStudent_marks'))) {
          /*_loadedfields!.add('user_subject_control_type.plStudent_marks'); */ obj
                  .plStudent_marks =
              obj.plStudent_marks ??
                  await obj.getStudent_marks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plUser'))) {
          obj.plUser =
              obj.plUser ?? await obj.getUser(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSubject'))) {
          obj.plSubject =
              obj.plSubject ?? await obj.getSubject(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plControl_type'))) {
          obj.plControl_type = obj.plControl_type ??
              await obj.getControl_type(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plUserByStudent_id'))) {
          obj.plUserByStudent_id = obj.plUserByStudent_id ??
              await obj.getUserByStudent_id(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [User_subject_control_type]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> User_subject_control_type?
  @override
  Future<User_subject_control_type> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        User_subject_control_type();
  }

  /// This method returns int. [User_subject_control_type]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? user_subject_control_typeCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final user_subject_control_typesFuture =
        await _mnUser_subject_control_type!.toList(qparams);
    final int count = user_subject_control_typesFuture[0]['CNT'] as int;
    if (user_subject_control_typeCount != null) {
      user_subject_control_typeCount(count);
    }
    return count;
  }

  /// This method returns List<User_subject_control_type> [User_subject_control_type]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<User_subject_control_type>
  @override
  Future<List<User_subject_control_type>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<User_subject_control_type> user_subject_control_typesData =
        await User_subject_control_type.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return user_subject_control_typesData;
  }

  /// This method returns Json String [User_subject_control_type]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [User_subject_control_type]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [User_subject_control_type]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnUser_subject_control_type!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [User_subject_control_type]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM user_subject_control_type WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnUser_subject_control_type!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [User_subject_control_type]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnUser_subject_control_type!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await User_subject_control_type.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnUser_subject_control_type!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion User_subject_control_typeFilterBuilder

// region User_subject_control_typeFields
class User_subject_control_typeFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fSemester;
  static TableField get semester {
    return _fSemester = _fSemester ??
        SqlSyntax.setField(_fSemester, 'semester', DbType.integer);
  }

  static TableField? _fHours_number;
  static TableField get hours_number {
    return _fHours_number = _fHours_number ??
        SqlSyntax.setField(_fHours_number, 'hours_number', DbType.integer);
  }

  static TableField? _fVersion;
  static TableField get version {
    return _fVersion =
        _fVersion ?? SqlSyntax.setField(_fVersion, 'version', DbType.integer);
  }

  static TableField? _fTeacher_id;
  static TableField get teacher_id {
    return _fTeacher_id = _fTeacher_id ??
        SqlSyntax.setField(_fTeacher_id, 'teacher_id', DbType.integer);
  }

  static TableField? _fSubject_id;
  static TableField get subject_id {
    return _fSubject_id = _fSubject_id ??
        SqlSyntax.setField(_fSubject_id, 'subject_id', DbType.integer);
  }

  static TableField? _fControl_type_id;
  static TableField get control_type_id {
    return _fControl_type_id = _fControl_type_id ??
        SqlSyntax.setField(
            _fControl_type_id, 'control_type_id', DbType.integer);
  }

  static TableField? _fStudent_id;
  static TableField get student_id {
    return _fStudent_id = _fStudent_id ??
        SqlSyntax.setField(_fStudent_id, 'student_id', DbType.integer);
  }
}
// endregion User_subject_control_typeFields

//region User_subject_control_typeManager
class User_subject_control_typeManager extends SqfEntityProvider {
  User_subject_control_typeManager()
      : super(ElectronicRecordCardDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'user_subject_control_type';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion User_subject_control_typeManager
// region Student_mark
class Student_mark extends TableBase {
  Student_mark(
      {this.id,
      this.completion_date,
      this.version,
      this.saved,
      this.mark_id,
      this.user_subject_control_type_id}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Student_mark.withFields(this.id, this.completion_date, this.version,
      this.saved, this.mark_id, this.user_subject_control_type_id) {
    _setDefaultValues();
  }
  Student_mark.withId(this.id, this.completion_date, this.version, this.saved,
      this.mark_id, this.user_subject_control_type_id) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Student_mark.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['completion_date'] != null) {
      completion_date = int.tryParse(o['completion_date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['completion_date'].toString())!)
          : DateTime.tryParse(o['completion_date'].toString());
    }
    if (o['version'] != null) {
      version = int.tryParse(o['version'].toString());
    }
    if (o['saved'] != null) {
      saved = o['saved'].toString() == '1' || o['saved'].toString() == 'true';
    }
    mark_id = int.tryParse(o['mark_id'].toString());

    user_subject_control_type_id =
        int.tryParse(o['user_subject_control_type_id'].toString());

    // RELATIONSHIPS FromMAP
    plMark = o['mark'] != null
        ? Mark.fromMap(o['mark'] as Map<String, dynamic>)
        : null;
    plUser_subject_control_type = o['user_subject_control_type'] != null
        ? User_subject_control_type.fromMap(
            o['user_subject_control_type'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Student_mark)
  int? id;
  DateTime? completion_date;
  int? version;
  bool? saved;
  int? mark_id;
  int? user_subject_control_type_id;
  bool? isSaved;
  // end FIELDS (Student_mark)

// RELATIONSHIPS (Student_mark)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plMark', 'plField2'..]) or so on..
  Mark? plMark;

  /// get Mark By Mark_id
  Future<Mark?> getMark(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Mark()
        .getById(mark_id, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plUser_subject_control_type', 'plField2'..]) or so on..
  User_subject_control_type? plUser_subject_control_type;

  /// get User_subject_control_type By User_subject_control_type_id
  Future<User_subject_control_type?> getUser_subject_control_type(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await User_subject_control_type().getById(
        user_subject_control_type_id,
        loadParents: loadParents,
        loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Student_mark)

  static const bool _softDeleteActivated = false;
  Student_markManager? __mnStudent_mark;

  Student_markManager get _mnStudent_mark {
    return __mnStudent_mark = __mnStudent_mark ?? Student_markManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (completion_date != null) {
      map['completion_date'] = forJson
          ? '$completion_date!.year-$completion_date!.month-$completion_date!.day'
          : forQuery
              ? DateTime(completion_date!.year, completion_date!.month,
                      completion_date!.day)
                  .millisecondsSinceEpoch
              : completion_date;
    } else if (completion_date != null || !forView) {
      map['completion_date'] = null;
    }
    if (version != null || !forView) {
      map['version'] = version;
    }
    if (saved != null) {
      map['saved'] = forQuery ? (saved! ? 1 : 0) : saved;
    } else if (saved != null || !forView) {
      map['saved'] = null;
    }
    if (mark_id != null) {
      map['mark_id'] = forView
          ? plMark == null
              ? mark_id
              : plMark!.name
          : mark_id;
    } else if (mark_id != null || !forView) {
      map['mark_id'] = null;
    }
    if (user_subject_control_type_id != null) {
      map['user_subject_control_type_id'] = forView
          ? plUser_subject_control_type == null
              ? user_subject_control_type_id
              : plUser_subject_control_type!.id
          : user_subject_control_type_id;
    } else if (user_subject_control_type_id != null || !forView) {
      map['user_subject_control_type_id'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (completion_date != null) {
      map['completion_date'] = forJson
          ? '$completion_date!.year-$completion_date!.month-$completion_date!.day'
          : forQuery
              ? DateTime(completion_date!.year, completion_date!.month,
                      completion_date!.day)
                  .millisecondsSinceEpoch
              : completion_date;
    } else if (completion_date != null || !forView) {
      map['completion_date'] = null;
    }
    if (version != null || !forView) {
      map['version'] = version;
    }
    if (saved != null) {
      map['saved'] = forQuery ? (saved! ? 1 : 0) : saved;
    } else if (saved != null || !forView) {
      map['saved'] = null;
    }
    if (mark_id != null) {
      map['mark_id'] = forView
          ? plMark == null
              ? mark_id
              : plMark!.name
          : mark_id;
    } else if (mark_id != null || !forView) {
      map['mark_id'] = null;
    }
    if (user_subject_control_type_id != null) {
      map['user_subject_control_type_id'] = forView
          ? plUser_subject_control_type == null
              ? user_subject_control_type_id
              : plUser_subject_control_type!.id
          : user_subject_control_type_id;
    } else if (user_subject_control_type_id != null || !forView) {
      map['user_subject_control_type_id'] = null;
    }

    return map;
  }

  /// This method returns Json String [Student_mark]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Student_mark]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      id,
      completion_date != null ? completion_date!.millisecondsSinceEpoch : null,
      version,
      saved,
      mark_id,
      user_subject_control_type_id
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      completion_date != null ? completion_date!.millisecondsSinceEpoch : null,
      version,
      saved,
      mark_id,
      user_subject_control_type_id
    ];
  }

  static Future<List<Student_mark>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Student_mark.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Student_mark>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Student_mark>[];
    try {
      objList = list
          .map((student_mark) =>
              Student_mark.fromMap(student_mark as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Student_mark.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Student_mark>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Student_mark> objList = <Student_mark>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Student_mark.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plMark'))) {
          obj.plMark =
              obj.plMark ?? await obj.getMark(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plUser_subject_control_type'))) {
          obj.plUser_subject_control_type = obj.plUser_subject_control_type ??
              await obj.getUser_subject_control_type(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Student_mark by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Student_mark] if exist, otherwise returns null
  Future<Student_mark?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Student_mark? obj;
    final data = await _mnStudent_mark.getById([id]);
    if (data.length != 0) {
      obj = Student_mark.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plMark'))) {
          obj.plMark =
              obj.plMark ?? await obj.getMark(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plUser_subject_control_type'))) {
          obj.plUser_subject_control_type = obj.plUser_subject_control_type ??
              await obj.getUser_subject_control_type(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Student_mark) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnStudent_mark.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnStudent_mark.update(this);
    }

    return id;
  }

  /// Saves the (Student_mark) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnStudent_mark.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnStudent_mark.updateOrThrow(this);
    }

    return id;
  }

  /// saveAll method saves the sent List<Student_mark> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Student_mark> student_marks,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ElectronicRecordCardDbModel().batchStart();
    for (final obj in student_marks) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await ElectronicRecordCardDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnStudent_mark.rawInsert(
          'INSERT OR REPLACE INTO student_mark (id, completion_date, version, saved, mark_id, user_subject_control_type_id)  VALUES (?,?,?,?,?,?)',
          [
            id,
            completion_date != null
                ? completion_date!.millisecondsSinceEpoch
                : null,
            version,
            saved,
            mark_id,
            user_subject_control_type_id
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Student_mark id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Student_mark id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Student_mark Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Student_mark>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Student_mark> student_marks,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnStudent_mark.rawInsertAll(
        'INSERT OR REPLACE INTO student_mark (id, completion_date, version, saved, mark_id, user_subject_control_type_id)  VALUES (?,?,?,?,?,?)',
        student_marks,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Student_mark

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Student_mark invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnStudent_mark
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnStudent_mark.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Student_mark] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Student_markFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Student_markFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Student_markFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Student_markFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    saved = saved ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion student_mark

// region Student_markField
class Student_markField extends FilterBase {
  Student_markField(Student_markFilterBuilder student_markFB)
      : super(student_markFB);

  @override
  Student_markFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Student_markFilterBuilder;
  }

  @override
  Student_markFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Student_markFilterBuilder;
  }

  @override
  Student_markFilterBuilder isNull() {
    return super.isNull() as Student_markFilterBuilder;
  }

  @override
  Student_markFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Student_markFilterBuilder;
  }

  @override
  Student_markFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Student_markFilterBuilder;
  }

  @override
  Student_markFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Student_markFilterBuilder;
  }

  @override
  Student_markFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Student_markFilterBuilder;
  }

  @override
  Student_markFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Student_markFilterBuilder;
  }

  @override
  Student_markFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Student_markFilterBuilder;
  }

  @override
  Student_markFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Student_markFilterBuilder;
  }

  @override
  Student_markFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Student_markFilterBuilder;
  }

  @override
  Student_markFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Student_markFilterBuilder;
  }

  @override
  Student_markField get not {
    return super.not as Student_markField;
  }
}
// endregion Student_markField

// region Student_markFilterBuilder
class Student_markFilterBuilder extends ConjunctionBase {
  Student_markFilterBuilder(Student_mark obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnStudent_mark = obj._mnStudent_mark;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Student_markManager? _mnStudent_mark;

  /// put the sql keyword 'AND'
  @override
  Student_markFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Student_markFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Student_markFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Student_markFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Student_markFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Student_markFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Student_markFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Student_markFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Student_markFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Student_markFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Student_markFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Student_markField _setField(
      Student_markField? field, String colName, DbType dbtype) {
    return Student_markField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Student_markField? _id;
  Student_markField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  Student_markField? _completion_date;
  Student_markField get completion_date {
    return _completion_date =
        _setField(_completion_date, 'completion_date', DbType.date);
  }

  Student_markField? _version;
  Student_markField get version {
    return _version = _setField(_version, 'version', DbType.integer);
  }

  Student_markField? _saved;
  Student_markField get saved {
    return _saved = _setField(_saved, 'saved', DbType.bool);
  }

  Student_markField? _mark_id;
  Student_markField get mark_id {
    return _mark_id = _setField(_mark_id, 'mark_id', DbType.integer);
  }

  Student_markField? _user_subject_control_type_id;
  Student_markField get user_subject_control_type_id {
    return _user_subject_control_type_id = _setField(
        _user_subject_control_type_id,
        'user_subject_control_type_id',
        DbType.integer);
  }

  /// Deletes List<Student_mark> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnStudent_mark!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnStudent_mark!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from student_mark ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnStudent_mark!.updateBatch(qparams, values);
  }

  /// This method always returns [Student_mark] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Student_mark?
  @override
  Future<Student_mark?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnStudent_mark!.toList(qparams);
    final data = await objFuture;
    Student_mark? obj;
    if (data.isNotEmpty) {
      obj = Student_mark.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plMark'))) {
          obj.plMark =
              obj.plMark ?? await obj.getMark(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plUser_subject_control_type'))) {
          obj.plUser_subject_control_type = obj.plUser_subject_control_type ??
              await obj.getUser_subject_control_type(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Student_mark]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Student_mark?
  @override
  Future<Student_mark> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Student_mark();
  }

  /// This method returns int. [Student_mark]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? student_markCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final student_marksFuture = await _mnStudent_mark!.toList(qparams);
    final int count = student_marksFuture[0]['CNT'] as int;
    if (student_markCount != null) {
      student_markCount(count);
    }
    return count;
  }

  /// This method returns List<Student_mark> [Student_mark]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Student_mark>
  @override
  Future<List<Student_mark>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Student_mark> student_marksData = await Student_mark.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return student_marksData;
  }

  /// This method returns Json String [Student_mark]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Student_mark]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Student_mark]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnStudent_mark!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Student_mark]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM student_mark WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnStudent_mark!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Student_mark]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnStudent_mark!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Student_mark.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnStudent_mark!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Student_markFilterBuilder

// region Student_markFields
class Student_markFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fCompletion_date;
  static TableField get completion_date {
    return _fCompletion_date = _fCompletion_date ??
        SqlSyntax.setField(_fCompletion_date, 'completion_date', DbType.date);
  }

  static TableField? _fVersion;
  static TableField get version {
    return _fVersion =
        _fVersion ?? SqlSyntax.setField(_fVersion, 'version', DbType.integer);
  }

  static TableField? _fSaved;
  static TableField get saved {
    return _fSaved =
        _fSaved ?? SqlSyntax.setField(_fSaved, 'saved', DbType.bool);
  }

  static TableField? _fMark_id;
  static TableField get mark_id {
    return _fMark_id =
        _fMark_id ?? SqlSyntax.setField(_fMark_id, 'mark_id', DbType.integer);
  }

  static TableField? _fUser_subject_control_type_id;
  static TableField get user_subject_control_type_id {
    return _fUser_subject_control_type_id = _fUser_subject_control_type_id ??
        SqlSyntax.setField(_fUser_subject_control_type_id,
            'user_subject_control_type_id', DbType.integer);
  }
}
// endregion Student_markFields

//region Student_markManager
class Student_markManager extends SqfEntityProvider {
  Student_markManager()
      : super(ElectronicRecordCardDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'student_mark';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion Student_markManager
// region User_role
class User_role extends TableBase {
  User_role({this.roleId, this.userId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  User_role.withFields(this.roleId, this.userId) {
    _setDefaultValues();
  }
  User_role.withId(this.roleId, this.userId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  User_role.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    roleId = int.tryParse(o['roleId'].toString());

    userId = int.tryParse(o['userId'].toString());

    // RELATIONSHIPS FromMAP
    plRole = o['role'] != null
        ? Role.fromMap(o['role'] as Map<String, dynamic>)
        : null;
    plUser = o['user'] != null
        ? User.fromMap(o['user'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (User_role)
  int? roleId;
  int? userId;
  bool? isSaved;
  // end FIELDS (User_role)

// RELATIONSHIPS (User_role)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plRole', 'plField2'..]) or so on..
  Role? plRole;

  /// get Role By RoleId
  Future<Role?> getRole(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Role()
        .getById(roleId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plUser', 'plField2'..]) or so on..
  User? plUser;

  /// get User By UserId
  Future<User?> getUser(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await User()
        .getById(userId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (User_role)

  static const bool _softDeleteActivated = false;
  User_roleManager? __mnUser_role;

  User_roleManager get _mnUser_role {
    return __mnUser_role = __mnUser_role ?? User_roleManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (roleId != null) {
      map['roleId'] = forView
          ? plRole == null
              ? roleId
              : plRole!.name
          : roleId;
    } else if (roleId != null || !forView) {
      map['roleId'] = null;
    }
    if (userId != null) {
      map['userId'] = forView
          ? plUser == null
              ? userId
              : plUser!.login
          : userId;
    } else if (userId != null || !forView) {
      map['userId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (roleId != null) {
      map['roleId'] = forView
          ? plRole == null
              ? roleId
              : plRole!.name
          : roleId;
    } else if (roleId != null || !forView) {
      map['roleId'] = null;
    }
    if (userId != null) {
      map['userId'] = forView
          ? plUser == null
              ? userId
              : plUser!.login
          : userId;
    } else if (userId != null || !forView) {
      map['userId'] = null;
    }

    return map;
  }

  /// This method returns Json String [User_role]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [User_role]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [roleId, userId];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [roleId, userId];
  }

  static Future<List<User_role>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR User_role.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<User_role>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <User_role>[];
    try {
      objList = list
          .map((user_role) =>
              User_role.fromMap(user_role as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR User_role.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<User_role>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<User_role> objList = <User_role>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = User_role.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plRole'))) {
          obj.plRole =
              obj.plRole ?? await obj.getRole(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plUser'))) {
          obj.plUser =
              obj.plUser ?? await obj.getUser(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns User_role by ID if exist, otherwise returns null
  /// Primary Keys: int? roleId, int? userId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [User_role] if exist, otherwise returns null
  Future<User_role?> getById(int? roleId, int? userId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (roleId == null) {
      return null;
    }
    User_role? obj;
    final data = await _mnUser_role.getById([roleId, userId]);
    if (data.length != 0) {
      obj = User_role.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plRole'))) {
          obj.plRole =
              obj.plRole ?? await obj.getRole(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plUser'))) {
          obj.plUser =
              obj.plUser ?? await obj.getUser(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (User_role) object. If the Primary Key (roleId) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same roleId
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnUser_role.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO user_role ( roleId, userId)  VALUES (?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<User_role> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<User_role> user_roles,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ElectronicRecordCardDbModel().batchStart();
    for (final obj in user_roles) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await ElectronicRecordCardDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnUser_role.rawInsert(
          'INSERT OR REPLACE INTO user_role ( roleId, userId)  VALUES (?,?)',
          [roleId, userId],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'User_role roleId=$roleId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'User_role roleId=$roleId did not update');
      }
      return roleId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'User_role Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<User_role>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<User_role> user_roles,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnUser_role.rawInsertAll(
        'INSERT OR REPLACE INTO user_role ( roleId, userId)  VALUES (?,?)',
        user_roles,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes User_role

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete User_role invoked (roleId=$roleId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnUser_role.delete(QueryParams(
          whereString: 'roleId=? AND userId=?',
          whereArguments: [roleId, userId]));
    } else {
      return _mnUser_role.updateBatch(
          QueryParams(
              whereString: 'roleId=? AND userId=?',
              whereArguments: [roleId, userId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [User_role] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  User_roleFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return User_roleFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  User_roleFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return User_roleFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      roleId = null;
      userId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion user_role

// region User_roleField
class User_roleField extends FilterBase {
  User_roleField(User_roleFilterBuilder user_roleFB) : super(user_roleFB);

  @override
  User_roleFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as User_roleFilterBuilder;
  }

  @override
  User_roleFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as User_roleFilterBuilder;
  }

  @override
  User_roleFilterBuilder isNull() {
    return super.isNull() as User_roleFilterBuilder;
  }

  @override
  User_roleFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as User_roleFilterBuilder;
  }

  @override
  User_roleFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as User_roleFilterBuilder;
  }

  @override
  User_roleFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as User_roleFilterBuilder;
  }

  @override
  User_roleFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as User_roleFilterBuilder;
  }

  @override
  User_roleFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as User_roleFilterBuilder;
  }

  @override
  User_roleFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as User_roleFilterBuilder;
  }

  @override
  User_roleFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as User_roleFilterBuilder;
  }

  @override
  User_roleFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as User_roleFilterBuilder;
  }

  @override
  User_roleFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as User_roleFilterBuilder;
  }

  @override
  User_roleField get not {
    return super.not as User_roleField;
  }
}
// endregion User_roleField

// region User_roleFilterBuilder
class User_roleFilterBuilder extends ConjunctionBase {
  User_roleFilterBuilder(User_role obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnUser_role = obj._mnUser_role;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  User_roleManager? _mnUser_role;

  /// put the sql keyword 'AND'
  @override
  User_roleFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  User_roleFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  User_roleFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  User_roleFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  User_roleFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  User_roleFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  User_roleFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  User_roleFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  User_roleFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  User_roleFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  User_roleFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  User_roleField _setField(
      User_roleField? field, String colName, DbType dbtype) {
    return User_roleField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  User_roleField? _roleId;
  User_roleField get roleId {
    return _roleId = _setField(_roleId, 'roleId', DbType.integer);
  }

  User_roleField? _userId;
  User_roleField get userId {
    return _userId = _setField(_userId, 'userId', DbType.integer);
  }

  /// Deletes List<User_role> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnUser_role!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnUser_role!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'roleId IN (SELECT roleId from user_role ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnUser_role!.updateBatch(qparams, values);
  }

  /// This method always returns [User_role] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> User_role?
  @override
  Future<User_role?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnUser_role!.toList(qparams);
    final data = await objFuture;
    User_role? obj;
    if (data.isNotEmpty) {
      obj = User_role.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plRole'))) {
          obj.plRole =
              obj.plRole ?? await obj.getRole(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plUser'))) {
          obj.plUser =
              obj.plUser ?? await obj.getUser(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [User_role]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> User_role?
  @override
  Future<User_role> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        User_role();
  }

  /// This method returns int. [User_role]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? user_roleCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final user_rolesFuture = await _mnUser_role!.toList(qparams);
    final int count = user_rolesFuture[0]['CNT'] as int;
    if (user_roleCount != null) {
      user_roleCount(count);
    }
    return count;
  }

  /// This method returns List<User_role> [User_role]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<User_role>
  @override
  Future<List<User_role>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<User_role> user_rolesData = await User_role.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return user_rolesData;
  }

  /// This method returns Json String [User_role]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [User_role]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [User_role]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnUser_role!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [User_role]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `roleId`userId` FROM user_role WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<roleId,userId> [User_role]
  /// <returns>List<roleId,userId>
  @override
  Future<List<User_role>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    qparams.selectColumns = ['roleId', 'userId'];
    final user_roleFuture = await _mnUser_role!.toList(qparams);
    return await User_role.fromMapList(user_roleFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [User_role]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnUser_role!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await User_role.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnUser_role!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion User_roleFilterBuilder

// region User_roleFields
class User_roleFields {
  static TableField? _fRoleId;
  static TableField get roleId {
    return _fRoleId =
        _fRoleId ?? SqlSyntax.setField(_fRoleId, 'roleId', DbType.integer);
  }

  static TableField? _fUserId;
  static TableField get userId {
    return _fUserId =
        _fUserId ?? SqlSyntax.setField(_fUserId, 'userId', DbType.integer);
  }
}
// endregion User_roleFields

//region User_roleManager
class User_roleManager extends SqfEntityProvider {
  User_roleManager()
      : super(ElectronicRecordCardDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'user_role';
  static const List<String> _primaryKeyList = ['roleId', 'userId'];
  static const String _whereStr = 'roleId=? AND userId=?';
}

//endregion User_roleManager
// region Mark_control_type
class Mark_control_type extends TableBase {
  Mark_control_type({this.control_typeId, this.markId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Mark_control_type.withFields(this.control_typeId, this.markId) {
    _setDefaultValues();
  }
  Mark_control_type.withId(this.control_typeId, this.markId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Mark_control_type.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    control_typeId = int.tryParse(o['control_typeId'].toString());

    markId = int.tryParse(o['markId'].toString());

    // RELATIONSHIPS FromMAP
    plControl_type = o['control_type'] != null
        ? Control_type.fromMap(o['control_type'] as Map<String, dynamic>)
        : null;
    plMark = o['mark'] != null
        ? Mark.fromMap(o['mark'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Mark_control_type)
  int? control_typeId;
  int? markId;
  bool? isSaved;
  // end FIELDS (Mark_control_type)

// RELATIONSHIPS (Mark_control_type)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plControl_type', 'plField2'..]) or so on..
  Control_type? plControl_type;

  /// get Control_type By Control_typeId
  Future<Control_type?> getControl_type(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Control_type().getById(control_typeId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plMark', 'plField2'..]) or so on..
  Mark? plMark;

  /// get Mark By MarkId
  Future<Mark?> getMark(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Mark()
        .getById(markId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Mark_control_type)

  static const bool _softDeleteActivated = false;
  Mark_control_typeManager? __mnMark_control_type;

  Mark_control_typeManager get _mnMark_control_type {
    return __mnMark_control_type =
        __mnMark_control_type ?? Mark_control_typeManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (control_typeId != null) {
      map['control_typeId'] = forView
          ? plControl_type == null
              ? control_typeId
              : plControl_type!.name
          : control_typeId;
    } else if (control_typeId != null || !forView) {
      map['control_typeId'] = null;
    }
    if (markId != null) {
      map['markId'] = forView
          ? plMark == null
              ? markId
              : plMark!.name
          : markId;
    } else if (markId != null || !forView) {
      map['markId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (control_typeId != null) {
      map['control_typeId'] = forView
          ? plControl_type == null
              ? control_typeId
              : plControl_type!.name
          : control_typeId;
    } else if (control_typeId != null || !forView) {
      map['control_typeId'] = null;
    }
    if (markId != null) {
      map['markId'] = forView
          ? plMark == null
              ? markId
              : plMark!.name
          : markId;
    } else if (markId != null || !forView) {
      map['markId'] = null;
    }

    return map;
  }

  /// This method returns Json String [Mark_control_type]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Mark_control_type]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [control_typeId, markId];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [control_typeId, markId];
  }

  static Future<List<Mark_control_type>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Mark_control_type.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Mark_control_type>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Mark_control_type>[];
    try {
      objList = list
          .map((mark_control_type) => Mark_control_type.fromMap(
              mark_control_type as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Mark_control_type.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Mark_control_type>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Mark_control_type> objList = <Mark_control_type>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Mark_control_type.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plControl_type'))) {
          obj.plControl_type = obj.plControl_type ??
              await obj.getControl_type(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plMark'))) {
          obj.plMark =
              obj.plMark ?? await obj.getMark(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Mark_control_type by ID if exist, otherwise returns null
  /// Primary Keys: int? control_typeId, int? markId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Mark_control_type] if exist, otherwise returns null
  Future<Mark_control_type?> getById(int? control_typeId, int? markId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (control_typeId == null) {
      return null;
    }
    Mark_control_type? obj;
    final data = await _mnMark_control_type.getById([control_typeId, markId]);
    if (data.length != 0) {
      obj = Mark_control_type.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plControl_type'))) {
          obj.plControl_type = obj.plControl_type ??
              await obj.getControl_type(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plMark'))) {
          obj.plMark =
              obj.plMark ?? await obj.getMark(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Mark_control_type) object. If the Primary Key (control_typeId) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same control_typeId
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnMark_control_type.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO mark_control_type ( control_typeId, markId)  VALUES (?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Mark_control_type> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<Mark_control_type> mark_control_types,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ElectronicRecordCardDbModel().batchStart();
    for (final obj in mark_control_types) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await ElectronicRecordCardDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnMark_control_type.rawInsert(
          'INSERT OR REPLACE INTO mark_control_type ( control_typeId, markId)  VALUES (?,?)',
          [control_typeId, markId],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Mark_control_type control_typeId=$control_typeId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Mark_control_type control_typeId=$control_typeId did not update');
      }
      return control_typeId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'Mark_control_type Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Mark_control_type>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Mark_control_type> mark_control_types,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnMark_control_type.rawInsertAll(
        'INSERT OR REPLACE INTO mark_control_type ( control_typeId, markId)  VALUES (?,?)',
        mark_control_types,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Mark_control_type

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete Mark_control_type invoked (control_typeId=$control_typeId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnMark_control_type.delete(QueryParams(
          whereString: 'control_typeId=? AND markId=?',
          whereArguments: [control_typeId, markId]));
    } else {
      return _mnMark_control_type.updateBatch(
          QueryParams(
              whereString: 'control_typeId=? AND markId=?',
              whereArguments: [control_typeId, markId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Mark_control_type] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Mark_control_typeFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Mark_control_typeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Mark_control_typeFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Mark_control_typeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      control_typeId = null;
      markId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion mark_control_type

// region Mark_control_typeField
class Mark_control_typeField extends FilterBase {
  Mark_control_typeField(Mark_control_typeFilterBuilder mark_control_typeFB)
      : super(mark_control_typeFB);

  @override
  Mark_control_typeFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Mark_control_typeFilterBuilder;
  }

  @override
  Mark_control_typeFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Mark_control_typeFilterBuilder;
  }

  @override
  Mark_control_typeFilterBuilder isNull() {
    return super.isNull() as Mark_control_typeFilterBuilder;
  }

  @override
  Mark_control_typeFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Mark_control_typeFilterBuilder;
  }

  @override
  Mark_control_typeFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Mark_control_typeFilterBuilder;
  }

  @override
  Mark_control_typeFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Mark_control_typeFilterBuilder;
  }

  @override
  Mark_control_typeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Mark_control_typeFilterBuilder;
  }

  @override
  Mark_control_typeFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Mark_control_typeFilterBuilder;
  }

  @override
  Mark_control_typeFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Mark_control_typeFilterBuilder;
  }

  @override
  Mark_control_typeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Mark_control_typeFilterBuilder;
  }

  @override
  Mark_control_typeFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Mark_control_typeFilterBuilder;
  }

  @override
  Mark_control_typeFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Mark_control_typeFilterBuilder;
  }

  @override
  Mark_control_typeField get not {
    return super.not as Mark_control_typeField;
  }
}
// endregion Mark_control_typeField

// region Mark_control_typeFilterBuilder
class Mark_control_typeFilterBuilder extends ConjunctionBase {
  Mark_control_typeFilterBuilder(Mark_control_type obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnMark_control_type = obj._mnMark_control_type;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Mark_control_typeManager? _mnMark_control_type;

  /// put the sql keyword 'AND'
  @override
  Mark_control_typeFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Mark_control_typeFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Mark_control_typeFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Mark_control_typeFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Mark_control_typeFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Mark_control_typeFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Mark_control_typeFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Mark_control_typeFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Mark_control_typeFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Mark_control_typeFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Mark_control_typeFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Mark_control_typeField _setField(
      Mark_control_typeField? field, String colName, DbType dbtype) {
    return Mark_control_typeField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Mark_control_typeField? _control_typeId;
  Mark_control_typeField get control_typeId {
    return _control_typeId =
        _setField(_control_typeId, 'control_typeId', DbType.integer);
  }

  Mark_control_typeField? _markId;
  Mark_control_typeField get markId {
    return _markId = _setField(_markId, 'markId', DbType.integer);
  }

  /// Deletes List<Mark_control_type> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnMark_control_type!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnMark_control_type!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'control_typeId IN (SELECT control_typeId from mark_control_type ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnMark_control_type!.updateBatch(qparams, values);
  }

  /// This method always returns [Mark_control_type] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Mark_control_type?
  @override
  Future<Mark_control_type?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnMark_control_type!.toList(qparams);
    final data = await objFuture;
    Mark_control_type? obj;
    if (data.isNotEmpty) {
      obj = Mark_control_type.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plControl_type'))) {
          obj.plControl_type = obj.plControl_type ??
              await obj.getControl_type(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plMark'))) {
          obj.plMark =
              obj.plMark ?? await obj.getMark(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Mark_control_type]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Mark_control_type?
  @override
  Future<Mark_control_type> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Mark_control_type();
  }

  /// This method returns int. [Mark_control_type]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? mark_control_typeCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final mark_control_typesFuture =
        await _mnMark_control_type!.toList(qparams);
    final int count = mark_control_typesFuture[0]['CNT'] as int;
    if (mark_control_typeCount != null) {
      mark_control_typeCount(count);
    }
    return count;
  }

  /// This method returns List<Mark_control_type> [Mark_control_type]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Mark_control_type>
  @override
  Future<List<Mark_control_type>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Mark_control_type> mark_control_typesData =
        await Mark_control_type.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return mark_control_typesData;
  }

  /// This method returns Json String [Mark_control_type]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Mark_control_type]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Mark_control_type]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnMark_control_type!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Mark_control_type]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `control_typeId`markId` FROM mark_control_type WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<control_typeId,markId> [Mark_control_type]
  /// <returns>List<control_typeId,markId>
  @override
  Future<List<Mark_control_type>> toListPrimaryKey(
      [bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    qparams.selectColumns = ['control_typeId', 'markId'];
    final mark_control_typeFuture = await _mnMark_control_type!.toList(qparams);
    return await Mark_control_type.fromMapList(mark_control_typeFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Mark_control_type]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnMark_control_type!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Mark_control_type.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnMark_control_type!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Mark_control_typeFilterBuilder

// region Mark_control_typeFields
class Mark_control_typeFields {
  static TableField? _fControl_typeId;
  static TableField get control_typeId {
    return _fControl_typeId = _fControl_typeId ??
        SqlSyntax.setField(_fControl_typeId, 'control_typeId', DbType.integer);
  }

  static TableField? _fMarkId;
  static TableField get markId {
    return _fMarkId =
        _fMarkId ?? SqlSyntax.setField(_fMarkId, 'markId', DbType.integer);
  }
}
// endregion Mark_control_typeFields

//region Mark_control_typeManager
class Mark_control_typeManager extends SqfEntityProvider {
  Mark_control_typeManager()
      : super(ElectronicRecordCardDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'mark_control_type';
  static const List<String> _primaryKeyList = ['control_typeId', 'markId'];
  static const String _whereStr = 'control_typeId=? AND markId=?';
}

//endregion Mark_control_typeManager
class ElectronicRecordCardDbModelSequenceManager extends SqfEntityProvider {
  ElectronicRecordCardDbModelSequenceManager()
      : super(ElectronicRecordCardDbModel());
}
// END OF ENTITIES
